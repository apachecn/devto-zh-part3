# ç”¨ Aeson ç¼–ç å’Œè§£ç  JSON

> åŸæ–‡:[https://dev . to/gill Christian/encoding-and-decoding-JSON-with-aeson-28af](https://dev.to/gillchristian/encoding-and-decoding-json-with-aeson-28af)

åœ¨è¿‡å»çš„å‡ å¤©é‡Œï¼Œæˆ‘ä¸€ç›´åœ¨å¼€å‘ä¸€ä¸ªå°åº”ç”¨ç¨‹åºï¼Œç”¨æ¥è§£ææˆ‘ä»é“¶è¡Œè·å¾—çš„äº¤æ˜“æŠ¥è¡¨ï¼Œæˆ‘çš„æƒ³æ³•æ˜¯ç”Ÿæˆä¸€äº›æ›´å®¹æ˜“å¯è§†åŒ–çš„ä¸œè¥¿ã€‚

æˆ‘å¾—åˆ°ä¸€ä¸ª`.txt`æ–‡ä»¶ï¼Œå…¶ä¸­æ¯ä¸€è¡Œå¯¹åº”ä¸€ä¸ªäº‹åŠ¡ï¼Œæˆ‘æƒ³ä»ä¸­ç”Ÿæˆä¸€ä¸ª JSON æ–‡ä»¶ï¼Œç„¶åæˆ‘å¯ä»¥åœ¨å›¾è¡¨åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨å®ƒã€‚

åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œæˆ‘é€šè¿‡ä½¿ç”¨ [Aeson](http://hackage.haskell.org/package/aeson-1.4.3.0/docs/Data-Aeson.html) äº†è§£äº†ä¸€äº›å…³äºåœ¨ Haskell ä¸­ä½¿ç”¨ JSON çš„äº‹æƒ…ã€‚

ä¸ºäº†å¯¹ JSON çš„å€¼è¿›è¡Œè§£ç å’Œç¼–ç ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†`decode`å’Œ`encode`æ–¹æ³•(å¾ˆå¥½çš„å‘½åğŸ˜‰).

```
decode :: FromJSON a => ByteString -> Maybe a
encode :: ToJSON a => a -> ByteString 
```

*æ³¨æ„*:é€šè¿‡è®¾ç½®[è¿‡è½½å­—ç¬¦ä¸²](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-strings)ç¼–è¯‘å™¨æ‰©å±•ï¼Œæˆ‘ä»¬ä¸ä»…å¯ä»¥å°†å­—ç¬¦ä¸²æ–‡å­—è§†ä¸º`String`ï¼Œè¿˜å¯ä»¥å°†å…¶è§†ä¸º`ByteString`ã€`Text`ç­‰ç­‰ã€‚

æˆ‘ä»¬å¯ä»¥ä»è¿™äº›ç±»å‹ç­¾åä¸­å­¦åˆ°å¾ˆå¤šå…³äº Aeson å¦‚ä½•å·¥ä½œçš„çŸ¥è¯†ã€‚

`decode`å–ä¸€ä¸ª`ByteString`(æˆ‘ä»¬å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªå­—ç¬¦ä¸²)å¹¶è¿”å›ä¸€ä¸ª`Maybe a`ï¼Œæ¡ä»¶æ˜¯è¿™ä¸ª`a`å¿…é¡»æœ‰`FromJSON`ç±»å‹çš„ç±»ã€‚æœ‰äº†è¿™ä¸ªåå­—ï¼Œæˆ‘ä»¬å¯ä»¥å‡è®¾å®ƒæ˜¯é’ˆå¯¹å¯ä»¥ä» JSON è§£æçš„ç±»å‹çš„ã€‚

å¦ä¸€æ–¹é¢ï¼Œ`encode`æ¥å—ä¸€ä¸ªç±»å‹ä¸º`a`çš„å€¼ï¼Œè¿™æ¬¡ä½¿ç”¨çš„æ˜¯`ToJSON`ç±»å‹çš„ç±»ï¼Œå¹¶è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥å‡è®¾`ToJSON`æ„å‘³ç€å¯ä»¥è½¬æ¢æˆ JSON çš„ç±»å‹ã€‚

è®©æˆ‘ä»¬è¯•ç€ä½¿ç”¨å®ƒä»¬ã€‚æ³¨æ„ï¼Œæˆ‘ä»¬éœ€è¦æŒ‡å®šè§£ç /ç¼–ç çš„ç±»å‹ï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±çŸ¥é“åº”è¯¥ä½¿ç”¨ FromJSON/TOJSON çš„å“ªä¸ªå®ä¾‹ã€‚

```
Î»> :set -XOverloadedStrings
Î»> import Data.Aeson
Î»> decode "true" :: Maybe Bool
Just True
Î»> decode "tru" :: Maybe Bool
Nothing
Î»> decode "123" :: Maybe Bool
Nothing
Î»> decode "123" :: Maybe Int
Just 123
Î»> encode (123 :: Int)
"123"
Î»> encode ("hola" :: String)
"\"hola\""
Î»> encode (Just 123 :: Maybe Int)
"123"
Î»> encode (Nothing :: Maybe Int)
"null" 
```

è§£ç ä¼šè¿”å›ä¸€ä¸ª`Maybe a`ï¼Œå› ä¸ºæˆ‘ä»¬ä¸çŸ¥é“å­—ç¬¦ä¸²ä¸­çš„ JSON æ ¼å¼æ˜¯å¦æ­£ç¡®ï¼Œæ‰€ä»¥æ“ä½œå¯èƒ½ä¼šå¤±è´¥ã€‚è€Œç¼–ç ï¼Œå› ä¸ºæˆ‘ä»¬æœ‰äº†`ToJSON`çº¦æŸï¼Œåº”è¯¥æ€»æ˜¯æˆåŠŸçš„ã€‚

æ‰€æœ‰è¿™äº›ç±»å‹éƒ½â€œå¼€ç®±å³ç”¨â€ï¼Œå› ä¸º Aeson å·²ç»å®ç°äº†è¿™äº›å®ä¾‹ğŸ‰

```
Î»> :i Int
data Int = ghc-prim-0.5.3:GHC.Types.I# ghc-prim-0.5.3:GHC.Prim.Int#
        -- Defined in â€˜ghc-prim-0.5.3:GHC.Typesâ€™
...
instance ToJSON Int
  -- Defined in â€˜aeson-1.4.2.0:Data.Aeson.Types.ToJSONâ€™
instance FromJSON Int
  -- Defined in â€˜aeson-1.4.2.0:Data.Aeson.Types.FromJSONâ€™ 
```

ä½†æ˜¯æˆ‘ä»¬ä¸ä¼šåªå¤„ç†åŸå§‹ç±»å‹ï¼Œå¯¹å—ï¼Ÿ

ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬è¯•å›¾ç¼–ç ä¸€ä¸ªè‡ªå®šä¹‰ç±»å‹çš„å€¼ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ã€‚

```
Î»> data Obj = Obj { id :: Int }
Î»> encode Obj { id = 1 }

<interactive>:5:1: error:
    â€¢ No instance for (ToJSON Obj) arising from a use of â€˜encodeâ€™
    â€¢ In the expression: encode Obj {id = 1}
      In an equation for â€˜itâ€™: it = encode Obj {id = 1} 
```

æˆ‘ä»¬éœ€è¦ä¸ºè¿™ç§ç±»å‹å®ç°`ToJSON`ã€‚

```
Î»> :i ToJSON
class ToJSON a where
  toJSON :: a -> Value
  default toJSON :: (GHC.Generics.Generic a,
                     aeson-1.4.2.0:Data.Aeson.Types.ToJSON.GToJSON
                       Value Zero (GHC.Generics.Rep a)) =>
                    a -> Value
  toEncoding :: a -> Encoding
  toJSONList :: [a] -> Value
  toEncodingList :: [a] -> Encoding
        -- Defined in â€˜aeson-1.4.2.0:Data.Aeson.Types.ToJSONâ€™ 
```

æˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨å®Œæˆ:

```
{-# LANGUAGE OverloadedStrings #-}

import Data.Aeson

newtype Obj = Obj
  { a :: Int
  }

instance ToJSON Obj where
  toJSON Obj {a = a} = object [("a", toJSON a)]

-- object :: [Pair] -> Value
-- type Pair = (Text, Value) -- Value here is the Aeson.Value 
```

æˆ–è€…æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€äº›ç¼–è¯‘å™¨çš„é­”æ³•ï¼Œä½¿ç”¨ç¼–è¯‘å™¨æ‰©å±•æ¥å¸®æˆ‘ä»¬åšåˆ°è¿™ä¸€ç‚¹:[deriveany class](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=deriveanyclass#extension-DeriveAnyClass)&[DeriveGeneric](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=deriveanyclass#extension-DeriveGeneric)ã€‚

```
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric  #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Aeson

newtype Obj = Obj
  { a :: Int
  } deriving (Generic, ToJSON) 
```

è€Œè¿™é‡ŒğŸ‰

è¿™å°±æ˜¯æˆ‘ä»¬å¤§éƒ¨åˆ†æ—¶é—´è¦åšçš„äº‹æƒ…ï¼Œé™¤éæˆ‘ä»¬ä»¥æŸç§ç‰¹å®šçš„æ–¹å¼å¯¹æ•°æ®è¿›è¡Œç¼–ç æˆ–è§£ç ã€‚

å®ç°å’Œæ´¾ç”Ÿ`FromJSON`çš„å·¥ä½œéå¸¸ç›¸ä¼¼ï¼Œæ‰€ä»¥ä¸å€¼å¾—å±•ç¤ºã€‚

## [](#conclusion)ç»“è®º

æ´¾ç”Ÿç±»å‹ç±»å®ä¾‹çš„ç¼–è¯‘å™¨é­”åŠ›ä½¿å¾—åœ¨ Haskell ä¸­ä½¿ç”¨ JSON å˜å¾—éå¸¸å®¹æ˜“ã€‚æˆ‘ä»¬ä»ç„¶æ‹¥æœ‰æˆ‘ä»¬ç±»å‹çš„å®‰å…¨æ€§ï¼Œè€Œä¸å¿…åƒå…¶ä»–è¯­è¨€(ä¾‹å¦‚ Elm)é‚£æ ·ä¸ºæ‰€æœ‰ä¸œè¥¿å®ç°å®šåˆ¶çš„ç¼–ç å™¨/è§£ç å™¨ã€‚