# åˆ¶é€  transferZ(é›¶ä»¶å·:1)

> åŸæ–‡:[https://dev.to/itzmeanjan/making-of-transferz-part-1-n-3mjf](https://dev.to/itzmeanjan/making-of-transferz-part-1-n-3mjf)

æˆ‘ä»¬å¼€å§‹å§...

## [](#idea)æƒ³æ³•

æ„å»ºä¸€ä¸ªç”¨äºåœ¨ä½ çš„è®¾å¤‡ä¹‹é—´æ— çº¿ä¼ è¾“æ–‡ä»¶çš„ [flutter](https://flutter.dev/) åº”ç”¨ç¨‹åºï¼Œå¤§éƒ¨åˆ†æ˜¯ç”¨ [Dart è¯­è¨€](https://www.dartlang.org/)ç¼–å†™çš„ï¼ŒçœŸçš„å¾ˆæ£’ã€‚

### [](#info)ä¿¡æ¯

transferZ æ˜¯ä¸€ä¸ªå¼€æºé¡¹ç›®ï¼Œåœ¨è¿™é‡Œå¯ä»¥æ‰¾åˆ°æ•´ä¸ªæºä»£ç [ã€‚è¯·éšæ„æäº¤æ‚¨çš„ç®€å†ã€‚](https://github.com/itzmeanjan/transferZ)

ç°åœ¨ï¼Œä½ å¯ä»¥[ä¸‹è½½](https://github.com/itzmeanjan/transferZ/releases/download/v1.0/transferZ-1.0.apk)å¹¶åœ¨ä½ çš„è®¾å¤‡ä¸Šæµ‹è¯• *transferZ* ã€‚

ä»Šå¤©æˆ‘ä»¬å°†å®ç°è¿™ä¸ª Flutter åº”ç”¨ç¨‹åºçš„å®¢æˆ·ç«¯-æœåŠ¡å™¨éƒ¨åˆ†ã€‚

åœ¨è¿™ä¸ªç³»åˆ—çš„æœ€åï¼Œä½ å°†æœ‰ä¸€ä¸ªå·¥ä½œçš„æ–‡ä»¶ä¼ è¾“åº”ç”¨ç¨‹åºã€‚

> æƒ³è¿™ä¹ˆåšå—ï¼Ÿ
> 
> æ˜¯
> 
> å¥½å§ï¼Œè·Ÿæˆ‘æ¥ğŸ˜‰

## [](#model)å‹å·

ä¸€ä¸ªå™¨ä»¶å¯ä»¥åŒæ—¶åœ¨è¿™ä¸¤ç§æ¨¡å¼ä¸‹å·¥ä½œã€‚

1.  æ¥æ”¶
2.  å‘é€

åœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹ï¼Œè®¾å¤‡å°†è¡¨ç°å¾—åƒä¸€ä¸ª*å®¢æˆ·ç«¯*ï¼Œåœ¨åä¸€ç§æƒ…å†µä¸‹ï¼Œå®ƒå°†åªæ˜¯ä¸€ä¸ª*æœåŠ¡å™¨*ã€‚

å½“å¤„äº*æ¥æ”¶*æ¨¡å¼æ—¶ï¼Œç¬¬ä¸€ä¸ª*å®¢æˆ·ç«¯*è·å–ä¸€ä¸ªæ–‡ä»¶åˆ—è¡¨ï¼Œè¿™äº›æ–‡ä»¶å‡†å¤‡å¥½è¢«*æœåŠ¡å™¨*å…±äº«ã€‚

ç„¶åï¼Œå®ƒéå†æ–‡ä»¶åˆ—è¡¨å¹¶ä¸€ä¸ªæ¥ä¸€ä¸ªåœ°è·å–å®ƒä»¬ï¼Œè€Œ*æœåŠ¡å™¨*ç»§ç»­ç›‘å¬ä¼ å…¥çš„è¯·æ±‚ï¼Œå¦‚æœè¯·æ±‚æ¥è‡ªå…è®¸çš„å¯¹ç­‰ç‚¹ï¼Œå°±ä¸ºå®ƒä»¬æä¾›æœåŠ¡ã€‚

æ˜¯çš„ï¼Œå°±è¿™ä¹ˆç®€å•ğŸ˜„ã€‚

## [](#init)åˆå§‹åŒ–

è®©æˆ‘ä»¬å…ˆå†™ä¸€äº›ä»£ç ï¼Œè®©æˆ‘ä»¬çš„è®¾å¤‡åƒä¸€ä¸ªå®¢æˆ·ç«¯ä¸€æ ·å·¥ä½œã€‚

### [](#receive-mode)æ¥æ”¶æ¨¡å¼

ä¸‹é¢çš„ *import* è¯­å¥å°†ä¸ºæˆ‘ä»¬è·å–æ‰€éœ€çš„ Dart ç±»ã€‚

```
import 'dart:io';
import 'dart:convert' show json, utf8;
import 'dart:async'; 
```

ä¸€ä¸ªåä¸º Client çš„ç±»å°†åŒ…å«æ‰€æœ‰*å®¢æˆ·ç«¯*åŠŸèƒ½ï¼Œåœ¨*æ¥æ”¶æ¨¡å¼*ä¸­æ˜¾ç¤ºã€‚

```
class Client {
  String _peerIP; // this the server IP, where we'll connect
  int _peerPort; // port on which server listens

  HttpClient _httpClient;

  Client(this._peerIP, this._peerPort) {
    _httpClient = HttpClient(); // gets initialized in constructor block
  }
} 
```

ç°åœ¨åœ¨æˆ‘ä»¬çš„å®¢æˆ·ç«¯ç±»ä¸­æ·»åŠ ä¸€ä¸ªåä¸º *connect* çš„æ–¹æ³•ã€‚

```
// method GETs a certain path, and returns a HttpClientRequest object, which is to be closed later, to send that request to server.
Future<HttpClientRequest> connect(String path) async => await _httpClient
      .get(this._peerIP, this._peerPort, path)
      .catchError((e) => null); 
```

å½“æˆ‘ä»¬ä¸ºæˆ‘ä»¬çš„*å®¢æˆ·ç«¯*å»ºæ¨¡æ—¶ï¼Œé¦–å…ˆè·å–ä¸€ä¸ªæ–‡ä»¶åˆ—è¡¨ï¼Œè¿™äº›æ–‡ä»¶å‡†å¤‡å¥½ç”±*æœåŠ¡å™¨*å…±äº«ï¼Œæˆ‘ä»¬å°†åœ¨å®¢æˆ·ç«¯ç±»ä¸­éœ€è¦ä¸€ä¸ªåä¸º *fetchFileNames* çš„æ–¹æ³•ã€‚

```
Future<List<String>> fetchFileNames(HttpClientRequest req) async {
    // a map, stores JSON response from server
    var fileNames = <String, List<String>>{};
    // Completer class helps us to return a Future from this method and when Completer completes, result is send back.
    var completer = Completer<List<String>>();
    await req.close().then((HttpClientResponse resp) {
      if (resp.statusCode == 200)
        // in case of success, listen for data passed through Stream
        resp.listen(
          (data) => fileNames = serializeJSON(utf8.decode(data)), // decode response and then serialize it into Map<String, List<String>> 
          onDone: () => completer.complete(fileNames['files']), // extract list of file names and send that back
          onError: (e) => completer.complete(<String>[]), // send a blank list
          cancelOnError: true,
        );
      else
        // if HttpStatus other than 200, simply return a blank list
        resp.listen(
          (data) {},
          onDone: () => completer.complete(<String>[]),
          onError: (e) => completer.complete(<String>[]),
          cancelOnError: true,
        );
    });
    return completer.future;
  } 
```

å…³é—­ä»å‰é¢çš„*è¿æ¥*æ–¹æ³•æ¥æ”¶çš„ *HttpClientRequest* å¯¹è±¡ï¼Œç»™æˆ‘ä»¬ä¸€ä¸ª *HttpClientResponse* å¯¹è±¡ï¼Œç”¨äºè¯»å–æ¥è‡ª*æœåŠ¡å™¨*çš„å“åº”ã€‚

ç°åœ¨æˆ‘ä»¬éœ€è¦å®šä¹‰å¦ä¸€ä¸ªæ–¹æ³• *serializeJSON* ï¼Œå®ƒå°†å¸®åŠ©æˆ‘ä»¬å°† JSON å“åº”è½¬æ¢æˆ Map <å­—ç¬¦ä¸²ï¼ŒList <å­—ç¬¦ä¸²> >ã€‚

```
Map<String, List<String>> serializeJSON(String data) =>
    return Map<String, dynamic>.from(json.decode(data))
        .map((key, val) => MapEntry(key, List<String>.from(val))); 
```

> æˆ‘ä»¬ç°åœ¨æœ‰ä»€ä¹ˆï¼Ÿä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œæ˜¯ä»æœåŠ¡å™¨è·å–çš„æ–‡ä»¶åã€‚

è®©æˆ‘ä»¬ä»*æœåŠ¡å™¨*è·å–è¿™äº›æ–‡ä»¶ã€‚åœ¨*å®¢æˆ·ç«¯*ç±»ä¸­æ·»åŠ ä¸€ä¸ªæ–°æ–¹æ³• *fetchFile* ã€‚

```
Future<bool> fetchFile(HttpClientRequest req, String targetPath) async {
    var completer = Completer<bool>(); // returns a future of boolean type, to denote success or failure
    await req.close().then((HttpClientResponse resp) {
      if (resp.statusCode == 200)
        File(targetPath).openWrite(mode: FileMode.write).addStream(resp).then(
              (val) => completer.complete(true),
              onError: (e) => completer.complete(false),
            ); // file opened in write mode, and added response Stream into file.
      else
        resp.listen(
          (data) {},
          onDone: () => completer.complete(false),
          onError: (e) => completer.complete(false),
          cancelOnError: true,
        ); // in case of error, simply return false to denote failure
    });
    return completer.future;
  } 
```

å¦‚æœæ–‡ä»¶è¢«æ­£ç¡®æå–ï¼Œæ–¹æ³•è¿”å› trueï¼Œå¦åˆ™è¿”å› false

è¿˜æœ‰æœ€åä¸€ä¸ªæ–¹æ³•ï¼Œåä¸º *disconnect* ç”¨äºå…³é—­ HttpClient è¿æ¥ã€‚

```
disconnect() =>
      // never force close a http connection, by passing force value attribute true.
      _httpClient.close(); 
```

æˆ‘ä»¬å·²ç»å®Œæˆäº†å®¢æˆ·ç«¯å£°æ˜ğŸ˜ã€‚

### [](#send-mode)å‘é€æ¨¡å¼

å›åˆ°*æœåŠ¡å™¨*ã€‚è®©æˆ‘ä»¬é¦–å…ˆå®šä¹‰ä¸€ä¸ªç±»ï¼Œåä¸º Serverã€‚

```
import 'dart:io';
import 'dart:convert' show json;

class Server {
  String _host; // IP where on which server listens
  int _port; // port on which server listens for incoming connections
  List<String> _filteredPeers; // list of IP, which are permitted to request files
  List<String> _files; // files ready to be shared
  ServerStatusCallBack _serverStatusCallBack; // Server status callback, lets user know, what's happening
  bool isStopped = true; // server state denoter

  Server(this._host, this._port, this._filteredPeers, this._files,
      this._serverStatusCallBack); // constructor defined 
```

ä¸ºäº†æ§åˆ¶*æœåŠ¡å™¨*ï¼Œæˆ‘ä»¬éœ€è¦åœ¨è¿™ä¸ªç±»ä¸­å£°æ˜å¦ä¸€ä¸ªå˜é‡ã€‚

```
 HttpServer _httpServer; 
```

è®©æˆ‘ä»¬å¼€å§‹ç›‘å¬ä¼ å…¥çš„è¿æ¥ã€‚

```
initServer() async {
    await HttpServer.bind(this._host, this._port).then((HttpServer server) {
    // binds server on specified IP and port
      _httpServer = server; // initializes _httpServer, which will be useful for controlling server functionalities
      isStopped = false; // server state changed
      _serverStatusCallBack.generalUpdate('Server started'); // lets user know about it, using callback function
    }, onError: (e) {
      isStopped = true;
      _serverStatusCallBack.generalUpdate('Failed to start Server');
    });
    // listens for incoming request in asynchronous fashion
    await for (HttpRequest request in _httpServer) {
      handleRequest(request); // handles incoming request
    }
  } 
```

ä¸ºäº†å¤„ç†ä¼ å…¥çš„è¿æ¥ï¼Œåœ¨æˆ‘ä»¬çš„æœåŠ¡å™¨ç±»ä¸­æ·»åŠ ä¸€ä¸ªåä¸º *handleRequest* çš„æ–¹æ³•ã€‚

```
handleRequest(HttpRequest request) {
    // first checks whether device allowed to request file or not
    if (isPeerAllowed(request.connectionInfo.remoteAddress.address)) {
      if (request.method == 'GET')
        handleGETRequest(request); // only GET is permitted
      else
        request.response
          ..statusCode = HttpStatus.methodNotAllowed
          ..headers.contentType = ContentType.json
          ..write(json.encode(
              <String, int>{'status': 'GET method only'}))
          ..close().then(
              (val) => _serverStatusCallBack.updateServerStatus({
                    request.connectionInfo.remoteAddress.host:
                        'GET method only'}), onError: (e) {
            _serverStatusCallBack.updateServerStatus({
              request.connectionInfo.remoteAddress.host:
                  'Transfer Error'
            });
          }); // otherwise let client know about it by sending a JSON response, where HTTP statusCode is set as HttpStatus.methodNotAllowed
    } else
      request.response
        ..statusCode = HttpStatus.forbidden
        ..headers.contentType = ContentType.json
        ..write(
            json.encode(<String, int>{'status': 'Access denied'}))
        ..close().then(
            (val) =>
                _serverStatusCallBack.generalUpdate('Access Denied'),
            onError: (e) {
          _serverStatusCallBack.generalUpdate('Transfer Error');
        }); // if client is not permitted to access
  } 
```

åœ¨*ispeerlowed*ä¸­æ£€æŸ¥å¯¹ç­‰ä½“æ˜¯å¦å¯ä»¥è¢«æˆæƒè®¿é—®ã€‚

```
bool isPeerAllowed(String remoteAddress) =>
      this._filteredPeers.contains(remoteAddress); // _filteredPeers was supplied during instantiating this class 
```

ç”¨ *handleGETRequest* å¤„ç†è¿‡æ»¤åçš„ GET è¯·æ±‚çš„æ—¶é—´ã€‚

```
handleGETRequest(HttpRequest getRequest) {
    if (getRequest.uri.path == '/') {
    // client hits at `http://hostAddress:port/`, for fetching list of files to be shared 
      getRequest.response
        ..statusCode = HttpStatus.ok // statusCode 200
        ..headers.contentType = ContentType.json // JSON response sent
        ..write(json.encode(<String, List<String>>{"files": this._files})) // response to be processed by client for converting JSON string back to Map<String, List<String>>
        ..close().then(
            (val) => _serverStatusCallBack.updateServerStatus({
                  getRequest.connectionInfo.remoteAddress.host:
                      'Accessible file list shared'
                }), onError: (e) {
          _serverStatusCallBack.updateServerStatus({
            getRequest.connectionInfo.remoteAddress.host:
                'Transfer Error'
          }); // in case of error
        });
    } else {
      if (this._files.contains(getRequest.uri.path)) {
    // if client hits at `http://hostIP:port/filePath`, first it's checked whether this file is supposed to be shared or not
        String remote = getRequest.connectionInfo.remoteAddress.host;
        getRequest.response.statusCode = HttpStatus.ok;
        _serverStatusCallBack.updateServerStatus({
          getRequest.connectionInfo.remoteAddress.host:
              'File fetch in Progress'
        });
        // then file is opened and added into response Stream
        getRequest.response
            .addStream(File(getRequest.uri.path).openRead())
            .then(
          (val) {
            getRequest.response.close(); // close connection
            _serverStatusCallBack
                .updateServerStatus({remote: 'File fetched'});
          },
          onError: (e) {
            _serverStatusCallBack
                .updateServerStatus({remote: 'Transfer Error'}); // in case of error
          },
        );
      }
    }
  } 
```

æœ€åä½†åŒæ ·é‡è¦çš„æ˜¯ï¼Œä¸€ç§åœæ­¢æœåŠ¡å™¨çš„æ–¹æ³•ã€‚

```
stopServer() {
    isStopped = true;
    _httpServer?.close(force: true);
    _serverStatusCallBack.generalUpdate('Server stopped');
  } 
```

è¿™éƒ½æ˜¯å…³äº*æœåŠ¡å™¨*ğŸ˜ã€‚

ç°åœ¨å®šä¹‰ä¸€ä¸ªæŠ½è±¡ç±» *ServerStatusCallBack* ï¼Œä»¥ä¿ƒè¿›å›è°ƒåŠŸèƒ½ã€‚è¿™ä¸ªæŠ½è±¡ç±»éœ€è¦è¢«å®ç°ï¼Œæˆ‘ä»¬è®¡åˆ’ä»è¿™é‡Œå¼€å§‹ï¼Œæ§åˆ¶å’Œåœæ­¢*æœåŠ¡å™¨*ã€‚

```
abstract class ServerStatusCallBack {
  updateServerStatus(Map<String, String> msg); // a certain peer specific message

  generalUpdate(String msg); // general message about current server state
} 
```

## [](#run)è¿è¡Œ

æ˜¯æ—¶å€™è¿è¡Œæˆ‘ä»¬çš„å®¢æˆ·äº†ã€‚

### [](#receive-mode)æ¥æ”¶æ¨¡å¼

ç›®å‰ï¼Œæˆ‘å°†ç®€å•åœ°ä»å‘½ä»¤è¡Œåº”ç”¨ç¨‹åºè¿è¡Œå®¢æˆ·ç«¯ï¼Œè¿™å°†åœ¨åç»­æ–‡ç« ä¸­æ›´æ–°ï¼Œå½“æˆ‘ä»¬åœ¨ flutter ä¸­åˆ°è¾¾ UI ä¸Šä¸‹æ–‡æ—¶ã€‚

```
main() {
  var client = Client('x.x.x.x', 8000); // x.x.x.x -> server IP and 8000 is port number
// feel free to change port number, try keeping it >1024
  client.connect('/').then((HttpClientRequest req) {
    if (req != null) // checks whether server is down or not
      client.fetchFileNames(req).then((List<String> targetFiles) { // first fetch list of files by sending a request in `/` path
        targetFiles.forEach((path) { // fetch files, one by one
          client.connect(path).then((HttpClientRequest req) { // request for a file, with that file's name as request path
            if (req != null) { // if server finds request eligible
              print('fetching ${getTargetFilePath(path)}');
              client
                  .fetchFile(req, getTargetFilePath(path)) // fetch file
                  .then((bool isSuccess) { // after it's done, check for transfer status
                print(isSuccess
                    ? 'Successfully downloaded file'
                    : 'Failed to download file');
                if (targetFiles.last == path) {
                  print('complete');
                  client.disconnect(); // disconnect client, when we find that all files has been successfully fetched
                }
              });
            } else
              print('Connection Failed');
          });
        });
        if (targetFiles.isEmpty) {
          print('incomplete');
          client.disconnect(); // there might be a situation when client not permitted to access files, then we get an empty list of files, it's handled here
        }
      });
    else
      print('Connection Failed'); // couldn't connect to server, may be down
  });
}

// returns path where client will store fetched files
String getTargetFilePath(String path) =>
    '/path-to-target-directory-to-store-fetched-file/${path.split('/').last}'; 
```

### [](#send-mode)å‘é€æ¨¡å¼

åœ¨æœåŠ¡å™¨çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†æš‚æ—¶ä¿æŒå®ƒçš„å‘½ä»¤è¡Œå¯æ‰§è¡Œæ€§ã€‚

è®©æˆ‘ä»¬é¦–å…ˆå®šä¹‰ä¸€ä¸ªç±» *ServerDriver* ï¼Œå®ƒå®ç° *ServerStatusCallBack* ï¼Œè·å–æœåŠ¡å™¨çŠ¶æ€æ›´æ–°ã€‚

```
class ServerDriver extends ServerStatusCallBack {
  Server server;

  @override
  updateServerStatus(Map<String, String> msg) =>
    msg.forEach((key, val) =>
      print('$key -- $val')); // peer specific message, where key of Map<String, String> is peerIP

  @override
  generalUpdate(String msg) => print(msg); // general status update about server

  init() {
    server = Server(
        '0.0.0.0',
        8000,
        <String>['192.168.1.103', '192.168.1.102'], // these are allowed peers( clients ), can request for fetching files
        <String>[
          '/path-to-file/image.png',
          '/path-to-file/spidy_love.zip',
        ],
        this); // this -- because ServerStatusCallBack is implemented in this class
  }

  start() {
    server.initServer(); // starts receiving incoming requests
  }
} 
```

æœ€å *main()* å‡½æ•°åˆ›å»ºäº† *ServerDriver* çš„ä¸€ä¸ªå®ä¾‹ï¼Œå¯åŠ¨æœåŠ¡å™¨ã€‚

```
main() {
  var serverDriver = ServerDriver();
  serverDriver.init(); // binds server in a speficied address and port
  serverDriver.start(); // starts accepting incoming requests
} 
```

[![Client Server running on a Desktop](../Images/db5e816ae5c564e15e3746e59219b9d2.png)T2ã€‘](https://res.cloudinary.com/practicaldev/image/fetch/s--2rkBtm-f--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/z5zgk835gm2f3pmygj48.png)

è®°ä½ï¼Œè¿™ä¸ªå®¢æˆ·æœº-æœåŠ¡å™¨ç¨‹åºåœ¨å±€åŸŸç½‘(LAN)ä¸­å·¥ä½œã€‚æœ‰å…´è¶£åœ¨ä¸‡å·¥ä½œï¼Œç»™å®ƒä¸€ä¸ªå°è¯•ğŸ‘ã€‚

## [](#next)æ¥ä¸‹æ¥

ç›®å‰æˆ‘ä»¬æœ‰ä¸¤ä¸ªå·¥ä½œç¨‹åºï¼Œä¸€ä¸ªå®¢æˆ·ç«¯å’Œä¸€ä¸ªæœåŠ¡å™¨ï¼Œå®Œå…¨ç”¨ [Dart è¯­è¨€](https://www.dartlang.org/)ç¼–å†™ï¼Œæœ€ç»ˆå°†è¢«æ”¾å…¥ [Flutter](https://flutter.dev/) åº”ç”¨[T5ã€‘transferZT7ã€‘ä¸­ã€‚](https://github.com/itzmeanjan/transferZ)

åœ¨æœ¬ç³»åˆ—çš„ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ„å»º [*transferZ*]((https://github.com/itzmeanjan/transferZ)) çš„*å¯¹ç­‰å‘ç°*éƒ¨åˆ†ã€‚

åŒæ—¶å‰è¿™ä¸ª[å›è´­](https://github.com/itzmeanjan/transferZ)ï¼Œè¯•ç€ç©ä¸€ä¸‹ã€‚

ä½ å¯ä»¥è€ƒè™‘åœ¨ [Twitter](https://twitter.com/meanjanry) å’Œ [GitHub](https://github.com/itzmeanjan) ä¸Šå…³æ³¨æˆ‘ï¼Œäº†è§£æ›´å¤šæ¶ˆæ¯ã€‚

å†è§ğŸ˜‰ã€‚