# Rust ç¼–ç¨‹è¯­è¨€ä¸­çš„é”™è¯¯å¤„ç†

> åŸæ–‡:[https://dev . to/saium esh/error-handling-in-rust-programming-language-3g 4](https://dev.to/saiumesh/error-handling-in-rust-programming-language-3g4)

[![Alt text of image](../Images/6057e7d1956092186b90d852be69c090.png)T2ã€‘](https://res.cloudinary.com/practicaldev/image/fetch/s--r8TIqKK---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn-images-1.medium.com/max/1200/1%2Ay1BM50iNmvX1bcBLq5d5DA.jpeg)

å¦‚æœä½ åœ¨å…³æ³¨æ ˆæº¢å‡ºå¼€å‘è€…è°ƒæŸ¥ï¼Œä½ å¯èƒ½å·²ç»çœ‹åˆ° Rust è¿ç»­ä¸¤å¹´æˆä¸ºæœ€å—æ¬¢è¿çš„ç¼–ç¨‹è¯­è¨€ã€‚Rust å¯èƒ½æ˜¯æˆ‘è§è¿‡æœ€è¿·äººç¼–ç¨‹è¯­è¨€ï¼Œæˆ‘å®Œå…¨åŒæ„è¿™ä¸ªè°ƒæŸ¥ã€‚

è¯´åˆ°è¿™é‡Œï¼Œå­¦ä¹  Rust å¹¶ä¸å®¹æ˜“ï¼Œå­¦ä¹ æ›²çº¿éå¸¸é«˜ï¼Œå¦‚æœä½ åƒæˆ‘ä¸€æ ·æ¥è‡ª JavaScript ç­‰è¯­è¨€ï¼Œè¿™å°†æ˜¯ä¸€ä¸ªéå¸¸å…·æœ‰æŒ‘æˆ˜æ€§çš„æ—…ç¨‹ï¼Œä½†è¿™æ¡è‰°éš¾çš„é“è·¯æ˜¯å€¼å¾—çš„ã€‚

å¦‚æœä½ æ˜¯å­¦ä¹  Rust çš„æ–°æ‰‹ï¼Œæˆ‘å¼ºçƒˆå»ºè®®ä»ä»–ä»¬çš„[æ–‡æ¡£](https://doc.rust-lang.org/book/)å¼€å§‹ï¼ŒRust æœ‰æœ€å¥½çš„æ–‡æ¡£ä¹‹ä¸€ã€‚

ä»Šå¤©æˆ‘ä»¬å°†å­¦ä¹  rust ä¸­çš„[é”™è¯¯å¤„ç†](https://doc.rust-lang.org/1.30.0/book/second-edition/ch09-00-error-handling.html)ã€‚

å¦‚æœä½ æ¥è‡ªåƒ JavaScript è¿™æ ·çš„è¯­è¨€ï¼ŒJS å’Œ Rust å¤„ç†é”™è¯¯çš„æ–¹å¼æ˜¯æˆªç„¶ä¸åŒçš„ã€‚è¯´å¾—å¤Ÿå¤šäº†ï¼Œè®©æˆ‘ä»¬ä»ä¸€äº›ä»£ç å¼€å§‹ğŸ˜‹ğŸ˜‹ã€‚

åœ¨ç¼–ç ä»»ä½•ä¸œè¥¿ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å­¦ä¹ [é€‰é¡¹](https://doc.rust-lang.org/std/option/index.html)å’Œ[å¯¼è‡´](https://doc.rust-lang.org/std/result/)ç”Ÿé”ˆã€‚

**Rust ä¸­çš„é€‰é¡¹**ä»£è¡¨å¯é€‰å€¼:æ¯ä¸ªé€‰é¡¹è¦ä¹ˆæ˜¯æŸä¸ªä¸”åŒ…å«å€¼ï¼Œè¦ä¹ˆæ˜¯æ— ï¼Œä¸”ä¸åŒ…å«å€¼ã€‚é€‰é¡¹ç±»å‹åœ¨ Rust ä»£ç ä¸­éå¸¸å¸¸è§ï¼Œå› ä¸ºå®ƒä»¬æœ‰å¤šç§ç”¨é€”ã€‚

Rust ä¸­çš„**ç»“æœ**æ˜¯ç”¨äºè¿”å›å’Œä¼ æ’­é”™è¯¯çš„ç±»å‹ã€‚å®ƒæ˜¯ä¸€ä¸ªå¸¦æœ‰å˜é‡çš„æšä¸¾ï¼ŒOk(T)è¡¨ç¤ºæˆåŠŸå¹¶åŒ…å«ä¸€ä¸ªå€¼ï¼ŒErr(E)è¡¨ç¤ºé”™è¯¯å¹¶åŒ…å«ä¸€ä¸ªé”™è¯¯å€¼ã€‚

```
enum Result<T, E> {

 Ok(T),

 Err(E),

} 
```

ç°åœ¨è®©æˆ‘ä»¬çœ‹ä¸€äº›ä¾‹å­ã€‚

é¦–å…ˆæˆ‘ä»¬å°†å­¦ä¹ **é€‰é¡¹**

```
fn main() {
    // first let's define vector/array of numbers
    let numbers = vec![1, 2, 4];

    // now let's try to read value from vector
    let index_one = numbers[1];
    println!("value at index {}", index_one);

    // now let's try to read 10th index which doesn't exists
    // since Rust doesn't have neither null nor try/catch to handle error
    // so we will take leverage of **Option**

    // un comment below two line to check error ğŸ˜¢ğŸ˜¢

    // let out_of_index = numbers[10];
    // println!("this will throw error {}", out_of_index);

    // above code would result in following error
    // thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 10'

    // rust has very interesting way to handle these errors
    // we will take advantage of Option and get method from
    // vector to handle these kind of errors

    // get method of vector returns **Option** enum
    // Option will have two properties Some and None
    // let's see how to read/catch error
    match numbers.get(10) {
        Some(value) => println!("Hello {}", value),
        None => println!("Yo!! out of bound error")
    }

    // now let's see how to read value from it
    let result = match numbers.get(10) {
        Some(value) => value,
        None => &-1 // defaulting to -1
    };

    println!("result is {}", result);

    // as you can see above code works well but,
    // we can improve code by taking advantage of Result
} 
```

**ç°åœ¨ï¼Œè®©æˆ‘ä»¬ç¨å¾®æ”¹è¿›ä¸€ä¸‹ä¸Šé¢çš„ä»£ç **

```
fn read_from_vec(input: &Vec<i32>, index: usize) -> Result<i32, &'static str> {
    return match input.get(index) {
        Some(value) => Ok(*value),
        None => Err("Out of bound exception")
    }
}

fn main() {
    // now lets take same example and improve error handling
    let numbers = vec![1, 2, 4];
    let result = read_from_vec(&numbers, 2);

    // now since result is of type **Result** we can handle this in multiple ways
    if result.is_ok() {
        println!("got the value {}", result.unwrap());
    } else {
        println!("yo!! got the error {:?}", result.unwrap_err());
    }

    // above code works but there's an even better way to handle the same
    match result {
        Ok(data) => println!("indexed value {}", data),
        Err(err) => println!("error is  {}", err)
    } 
```

ç°åœ¨è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªè¯»å–æ–‡ä»¶çš„ä¸€èˆ¬ç”¨ä¾‹ã€‚

```
use std::io;
use std::io::Read;
use std::fs::File;

fn read_from_file(file_path: &'static str) -> Result<String, io::Error> {
    let mut file_data = String::new();

    // now let's try to read file
    // here ? is for handling errors
    // if there's an error it will break program and returns error
        // let mut f = File::open(file_path)?;
        // f.read_to_string(&mut file_data)?;
        // return Ok(file_data);

    // we can simplify above code by writing
    File::open(file_path)?.read_to_string(&mut file_data)?;
    Ok(file_data)

}

fn main() {
    // now let's see more generic use cases
    // for error handling

    let file_path = "hello.txt";
    match read_from_file(file_path) {
        Ok(data) => println!("file data {}", data),
        Err(err) => println!("err {}", err)
    };
} 
```

æˆ‘ä»åœ¨å­¦ä¹  Rustï¼Œå¸Œæœ›æˆ‘å¯¹ Rust è¯­è¨€ä¸­çš„é”™è¯¯å¤„ç†æœ‰æ‰€äº†è§£ã€‚å¦‚æœæ‚¨æœ‰ä»»ä½•ç–‘é—®æˆ–å»ºè®®ï¼Œå¯ä»¥åœ¨æˆ‘çš„ twitter ä¸Šè”ç³»æˆ‘ã€‚åœ¨é‚£ä¹‹å‰ï¼Œæˆ‘ä¼šåœ¨å…¶ä»–å²—ä½ä¸Šçœ‹åˆ°ä½ ã€‚å’Œå¹³â¤â¤