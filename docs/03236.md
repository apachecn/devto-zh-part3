# å¦‚ä½•åœ¨ iOS ä¸­ä½¿ç”¨ Stripe å’Œ Apple Pay

> åŸæ–‡:[https://dev . to/on myway 133/how-to-use-stripe-and-apple-pay-in-IOs-17an](https://dev.to/onmyway133/how-to-use-stripe-and-apple-pay-in-ios-17an)

*   [iOS é›†æˆ](https://stripe.com/docs/mobile/ios)
*   [è®¾ç½® Apple Pay è¦æ±‚](https://developer.apple.com/documentation/passkit/apple_pay/setting_up_apple_pay_requirements)
*   [Apple Pay](https://stripe.com/docs/apple-pay)

## [](#show-basic-add-card-in-ios)æ˜¾ç¤º iOS ä¸­çš„åŸºæœ¬æ·»åŠ å¡

```
import UIKit
import Stripe

final class MainController: UIViewController {

    func showPayment() {
        let addCardViewController = STPAddCardViewController()
        addCardViewController.delegate = self
        let navigationController = UINavigationController(rootViewController: addCardViewController)

        present(navigationController, animated: true, completion: nil)
    }
}

extension MainController: STPAddCardViewControllerDelegate {
    func addCardViewControllerDidCancel(_ addCardViewController: STPAddCardViewController) {
        dismiss(animated: true, completion: nil)
    }

    func addCardViewController(_ addCardViewController: STPAddCardViewController, didCreateToken token: STPToken, completion: @escaping STPErrorBlock) {
        _ = token.tokenId
        completion(nil)
        dismiss(animated: true, completion: nil)
    }
} 
```

## [](#generate-ephemeral-key)ç”Ÿæˆä¸´æ—¶å¯†é’¥

[https://stripe.com/docs/mobile/ios/standard#ephemeral-key](https://stripe.com/docs/mobile/ios/standard#ephemeral-key)

> ä¸ºäº†è®©æˆ‘ä»¬é¢„å…ˆæ„å»ºçš„ UI å…ƒç´ å‘æŒ¥ä½œç”¨ï¼Œæ‚¨éœ€è¦ä¸ºå®ƒä»¬æä¾›ä¸€ä¸ªä¸´æ—¶çš„å¯†é’¥ï¼Œä¸€ä¸ªå…·æœ‰å—é™ API è®¿é—®æƒé™çš„çŸ­æœŸ API å¯†é’¥ã€‚æ‚¨å¯ä»¥å°†ä¸´æ—¶å¯†é’¥è§†ä¸ºä¸€ä¸ªä¼šè¯ï¼Œæˆæƒ SDK åœ¨ä¼šè¯æœŸé—´æ£€ç´¢å’Œæ›´æ–°ç‰¹å®šçš„å®¢æˆ·å¯¹è±¡ã€‚

### [](#backend-in-go)åç«¯åœ¨èµ°

[https://github.com/stripe/stripe-go](https://github.com/stripe/stripe-go)

éœ€è¦å¯†é’¥ï¼Œè¯·è½¬åˆ°`Stripe dashboard -> Developers -> API keys -> Secret key`

```
stripe.Key = "sk_key" 
```

éœ€è¦å®¢æˆ· idã€‚æˆ‘ä»¬å¯ä»¥åœ¨`Stripe dashboard -> Customers`
ä¸­æ‰‹åŠ¨åˆ›å»ºä¸€ä¸ª

```
package main

import (
    "net"
    "encoding/json"
    "fmt"
    "net/http"
    "github.com/stripe/stripe-go"
    "github.com/stripe/stripe-go/ephemeralkey"
)

func main() {
    stripe.Key = "sk_test_mM2MkqO61n7vvbVRfeYmBgWm00Si2PtWab"

    http.HandleFunc("/ephemeral_keys", generateEphemeralKey)
    if err := http.ListenAndServe(":8080", nil); err != nil {
        panic(err)
    }
}

type EphemeralKeysRequest struct {
    ApiVersion string `json:"api_version"`
}

func generateEphemeralKey(w http.ResponseWriter, r *http.Request) {
    customerId := "cus_Eys6aeP5xR89ab"

    decoder := json.NewDecoder(r.Body)
    var t EphemeralKeysRequest
    err := decoder.Decode(&t)
    if err != nil {
        panic(err)
    }

    stripeVersion := t.ApiVersion
    if stripeVersion == "" {
        log.Printf("Stripe-Version not found\n")
        w.WriteHeader(400)
        return
    }
    params := &stripe.EphemeralKeyParams{
        Customer: stripe.String(customerId),
        StripeVersion: stripe.String(stripeVersion),
    }

    key, err := ephemeralkey.New(params)
    if err != nil {
        log.Printf("Stripe bindings call failed, %v\n", err)
        w.WriteHeader(500)
        return
    }
    w.Write(key.RawJSON)
} 
```

### [](#ios-client)iOS å®¢æˆ·ç«¯

ç½‘ç»œå®¢æˆ·ç«¯ä½¿ç”¨[å¦‚ä½•åœ¨ Swift ä¸­åˆ¶ä½œç®€å•çš„ç½‘ç»œå®¢æˆ·ç«¯](https://github.com/onmyway133/blog/issues/222)

éœ€è¦ä¸€ä¸ªç¬¦åˆ`STPCustomerEphemeralKeyProvider`
çš„å¯¹è±¡

```
final class EphemeralKeyClient: NSObject, STPCustomerEphemeralKeyProvider {
    let client = NetworkClient(baseUrl: URL(string: "http://localhost:8080")!)

    func createCustomerKey(withAPIVersion apiVersion: String, completion: @escaping STPJSONResponseCompletionBlock) {
        var options = Options()
        options.httpMethod = .post
        options.path = "ephemeral_keys"
        options.parameters = [
            "api_version": apiVersion
        ]

        client.makeJson(options: options, completion: { result in
            switch result {
            case .success(let json):
                completion(json, nil)
            case .failure(let error):
                completion(nil, error)
            }
        })
    }
} 
```

è®¾ç½®`STPCustomerContext`å’Œ`STPPaymentContext`

```
final class MainController: UIViewController {
    let client = EphemeralKeyClient()
    let customerContext: STPCustomerContext
    let paymentContext: STPPaymentContext

    init() {
        self.customerContext = STPCustomerContext(keyProvider: client)
        self.paymentContext = STPPaymentContext(customerContext: customerContext)
        super.init(nibName: nil, bundle: nil)
        paymentContext.delegate = self
        paymentContext.hostViewController = self
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    func start() {
        paymentContext.presentShippingViewController()
    }
} 
```

## [](#handle-charge)å¤„ç†æ”¶è´¹

[https://stripe.com/docs/charges](https://stripe.com/docs/charges)

### [](#backend-in-go)åç«¯åœ¨èµ°

å¦‚æœæˆ‘ä»¬ä½¿ç”¨æ¥è‡ªå¡çš„`stripe_id`ï¼Œå®ƒå…·æœ‰`card_xxx`çš„å½¢å¼ï¼Œæˆ‘ä»¬éœ€è¦åŒ…å«`customer`ä¿¡æ¯

å¦‚æœæˆ‘ä»¬ä½¿ç”¨å½¢å¼ä¸º`tok_xxx`çš„`token`ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦`customer`ä¿¡æ¯

ä»`STPPaymentResult`

> å½“æ‚¨ä½¿ç”¨`STPPaymentContext`è¯·æ±‚æ‚¨çš„ç”¨æˆ·çš„ä»˜æ¬¾ç»†èŠ‚æ—¶ï¼Œè¿™æ˜¯å½“ä»–ä»¬æˆåŠŸä»˜æ¬¾æ—¶å°†è¿”å›åˆ°æ‚¨çš„åº”ç”¨ç¨‹åºçš„å¯¹è±¡ã€‚å®ƒç›®å‰åªåŒ…å«ä¸€ä¸ª`source`ï¼Œä½†æ˜¯å°†æ¥ä¹Ÿä¼šåŒ…å«ä»»ä½•ç›¸å…³çš„å…ƒæ•°æ®ã€‚æ‚¨åº”è¯¥å°†`source.stripeID`ä¼ é€’åˆ°æ‚¨çš„æœåŠ¡å™¨ï¼Œå¹¶è°ƒç”¨æ”¶è´¹åˆ›å»ºç«¯ç‚¹ã€‚è¿™å‡è®¾æ‚¨æ­£åœ¨å‘ä¸€ä¸ªå®¢æˆ·æ”¶è´¹ï¼Œå› æ­¤æ‚¨åº”è¯¥å°†`customer`å‚æ•°æŒ‡å®šä¸ºè¯¥å®¢æˆ·çš„ IDï¼Œå°†`source`å‚æ•°æŒ‡å®šä¸ºè¿™é‡Œè¿”å›çš„å€¼ã€‚æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§[https://stripe.com/docs/api#create_charge](https://stripe.com/docs/api#create_charge)T7ã€‘

```
package main

import (
    "net"
    "encoding/json"
    "fmt"
    "net/http"
    "log"
    "os"
    "github.com/stripe/stripe-go/charge"
)

func main() {
    stripe.Key = "sk_test_mM2MkqO61n7vvbVRfeYmBgWm00Si2PtWab"

    http.HandleFunc("/request_charge", handleCharge)
    if err := http.ListenAndServe(":8080", nil); err != nil {
        panic(err)
    }
}

var customerId = "cus_Eys6aeP5xR89ab"

type PaymentResult struct {
    StripeId string `json:"stripe_id"`
}

func handleCharge(w http.ResponseWriter, r *http.Request) {
    decoder := json.NewDecoder(r.Body)
    var t PaymentResult
    err := decoder.Decode(&t)
    if err != nil {
        panic(err)
    }

    params := &stripe.ChargeParams{
        Amount:      stripe.Int64(150),
        Currency:    stripe.String(string(stripe.CurrencyUSD)),
        Description: stripe.String("Charge from my Go backend"),
        Customer: stripe.String(customerId),
    }

    params.SetSource(t.StripeId)
    ch, err := charge.New(params)
    if err != nil {
        fmt.Fprintf(w, "Could not process payment: %v", err)
        fmt.Println(ch)
        w.WriteHeader(400)
    }

    w.WriteHeader(200)
} 
```

### [](#ios-client)iOS å®¢æˆ·ç«¯

```
final class PaymentClient {
    let client = NetworkClient(baseUrl: URL(string: "http://192.168.210.219:8080")!)

    func requestCharge(source: STPSourceProtocol, completion: @escaping (Result<(), Error>) -> Void) {
        var options = Options()
        options.httpMethod = .post
        options.path = "request_charge"
        options.parameters = [
            "stripe_id": source.stripeID
        ]

        client.makeJson(options: options, completion: { result in
            completion(result.map({ _ in () }))
        })
    }
}

paymentContext.requestPayment()

extension MainController: STPPaymentContextDelegate {
    func paymentContext(_ paymentContext: STPPaymentContext, didCreatePaymentResult paymentResult: STPPaymentResult, completion: @escaping STPErrorBlock) {
        client.requestCharge(source: paymentResult.source, completion: { result in
            switch result {
            case .success:
                completion(nil)
            case .failure(let error):
                completion(error)
            }
        })
    }
} 
```

## [](#token-from-card)ä»¤ç‰Œæ¥è‡ªå¡

ä½¿ç”¨`STPAPIClient.shared().createToken`ä»å¡ä¸­è·å–ä»¤ç‰Œ[https://stripe . com/docs/mobile/IOs/custom # collecting-card-details](https://stripe.com/docs/mobile/ios/custom#collecting-card-details)T3ã€‘

```
let cardParams = STPCardParams()
cardParams.number = "4242424242424242"
cardParams.expMonth = 10
cardParams.expYear = 2021
cardParams.cvc = "123"

STPAPIClient.shared().createToken(withCard: cardParams) { (token: STPToken?, error: Error?) in
    guard let token = token, error == nil else {
        // Present error to user...
        return
    }

    submitTokenToBackend(token, completion: { (error: Error?) in
        if let error = error {
            // Present error to user...
        }
        else {
            // Continue with payment...
        }
    })
} 
```

## [](#payment-options-and-shipping-view-controllers)ä»˜æ¬¾é€‰é¡¹å’Œè¿è´¹æŸ¥çœ‹æ§åˆ¶å™¨

è€Œä¸æ˜¯ä½¿ç”¨`paymentContext`

```
paymentContext.pushShippingViewController()
paymentContext.pushPaymentOptionsViewController() 
```

æˆ‘ä»¬å¯ä»¥é€šè¿‡`STPPaymentOptionsViewController`å’Œ`STPShippingAddressViewController`ç›´æ¥ä½¿ç”¨è§†å›¾æ§åˆ¶å™¨[https://stripe . com/docs/mobile/IOs/custom # stppaymentoptionsviewcontroller](https://stripe.com/docs/mobile/ios/custom#stppaymentoptionsviewcontroller)ã€‚ç„¶åæ‰§è¡Œ`STPPaymentOptionsViewControllerDelegate`å’Œ`STPShippingAddressViewControllerDelegate`

## [](#register-merchant-id-and-apple-pay-certificate)æ³¨å†Œå•†æˆ· Id å’Œ Apple Pay è¯ä¹¦

[https://stripe.com/docs/apple-pay/apps](https://stripe.com/docs/apple-pay/apps)

ä»æ¡å¸¦[https://dashboard.stripe.com/account/apple_pay](https://dashboard.stripe.com/account/apple_pay)è·å–è¯ä¹¦ç­¾åè¯·æ±‚æ–‡ä»¶

æˆ‘ä»¬æ— æ³•ç”¨ä¼ä¸šå¸æˆ·æ³¨å†Œå•†æˆ· id

## [](#use-apple-pay)ä½¿ç”¨ Apple Pay

### [](#go-backend)èµ°åç«¯

ä½¿ç”¨ä»¤ç‰Œ

```
type ApplePayRequest struct {
    Token string `json:"token"`
}

func handleChargeUsingApplePay(w http.ResponseWriter, r *http.Request) {
    decoder := json.NewDecoder(r.Body)
    var t ApplePayRequest
    err := decoder.Decode(&t)
    if err != nil {
        panic(err)
    }

    params := &stripe.ChargeParams{
        Amount:      stripe.Int64(150),
        Currency:    stripe.String(string(stripe.CurrencyUSD)),
        Description: stripe.String("Charge from my Go backend for Apple Pay"),
    }

    params.SetSource(t.Token)
    ch, err := charge.New(params)
    if err != nil {
        fmt.Fprintf(w, "Could not process payment: %v", err)
        fmt.Println(ch)
        w.WriteHeader(400)
    }

    w.WriteHeader(200)
} 
```

### [](#ios-client)iOS å®¢æˆ·ç«¯

æ›´æ–°å®¢æˆ·ç«¯å‘é€`STPToken`

```
final class PaymentClient: NSObject {
    let client = NetworkClient(baseUrl: URL(string: "localhost:8080")!)

    func requestCharge(token: STPToken, completion: @escaping (Result<(), Error>) -> Void) {
        var options = Options()
        options.httpMethod = .post
        options.path = "request_charge_apple_pay"
        options.parameters = [
            "token": token.tokenId
        ]

        client.make(options: options, completion: { result in
            completion(result.map({ _ in () }))
        })
    }

    func useApplePay(payment: PKPayment, completion: @escaping (Result<(), Error>) -> Void) {
        STPAPIClient.shared().createToken(with: payment, completion: { (token: STPToken?, error: Error?) in
            guard let token = token, error == nil else {
                return
            }

            self.requestCharge(token: token, completion: completion)
        })
    }
} 
```

ä½¿ç”¨`PKPaymentAuthorizationViewController`ï¼Œä¸è¦ä½¿ç”¨`PKPaymentAuthorizationController`

[https://developer . apple . com/documentation/pass kit/pkpaymentauthorizationcontroller](https://developer.apple.com/documentation/passkit/pkpaymentauthorizationcontroller)

> PKPaymentAuthorizationController ç±»æ‰§è¡Œä¸ PKPaymentAuthorizationViewController ç±»ç›¸åŒçš„è§’è‰²ï¼Œä½†å®ƒä¸ä¾èµ–äº UIKit æ¡†æ¶ã€‚è¿™æ„å‘³ç€æˆæƒæ§åˆ¶å™¨å¯ä»¥åœ¨è§†å›¾æ§åˆ¶å™¨ä¸èƒ½ä½¿ç”¨çš„åœ°æ–¹ä½¿ç”¨(ä¾‹å¦‚ï¼Œåœ¨ watchOS åº”ç”¨ç¨‹åºæˆ– SiriKit æ‰©å±•ä¸­)ã€‚

```
extension MainController {
    func showApplePay() {
        let merchantId = "merchant.com.onmyway133.MyApp"
        let paymentRequest = Stripe.paymentRequest(withMerchantIdentifier: merchantId, country: "US", currency: "USD")
        paymentRequest.paymentSummaryItems = [
            PKPaymentSummaryItem(label: "Rubber duck", amount: 1.5)
        ]

        guard Stripe.canSubmitPaymentRequest(paymentRequest) else {
            assertionFailure()
            return
        }

        guard let authorizationViewController = PKPaymentAuthorizationViewController(paymentRequest: paymentRequest) else {
            assertionFailure()
            return
        }

        authorizationViewController.delegate = self
        innerNavigationController.present(authorizationViewController, animated: true, completion: nil)
    }
}

extension MainController: PKPaymentAuthorizationViewControllerDelegate {
    func paymentAuthorizationViewControllerDidFinish(_ controller: PKPaymentAuthorizationViewController) {
        controller.dismiss(animated: true, completion: nil)
    }

    func paymentAuthorizationViewController(
        _ controller: PKPaymentAuthorizationViewController,
        didAuthorizePayment payment: PKPayment,
        handler completion: @escaping (PKPaymentAuthorizationResult) -> Void) {

        client.useApplePay(payment: payment, completion: { result in
            switch result {
            case .success:
                completion(.init(status: .success, errors: nil))
            case .failure(let error):
                completion(.init(status: .failure, errors: [error]))
            }
        })
    }
} 
```

## [](#showing-apple-pay-option)æ˜¾ç¤º Apple Pay é€‰é¡¹

ä»`appleMerchantIdentifier`

> Apple Pay äº¤æ˜“æœŸé—´ä½¿ç”¨çš„ Apple å•†æˆ·æ ‡è¯†ç¬¦ã€‚è¦åˆ›å»ºå…¶ä¸­çš„ä¸€ä¸ªï¼Œè¯·çœ‹æˆ‘ä»¬åœ¨ https://stripe.com/docs/mobile/apple-pay çš„æŒ‡å—ã€‚æ‚¨å¿…é¡»å°†å…¶è®¾å®šä¸ºæœ‰æ•ˆçš„æ ‡è¯†ç¬¦ï¼Œä»¥ä¾¿è‡ªåŠ¨å¯ç”¨ Apple Payã€‚

```
if Stripe.deviceSupportsApplePay() {
    STPPaymentConfiguration.shared().appleMerchantIdentifier = "merchant.com.onmyway133.MyApp"
}

paymentContext.pushPaymentOptionsViewController() 
```

## [](#requestpayment-not-showing-ui)è¯·æ±‚ä»˜æ¬¾ä¸æ˜¾ç¤ºç•Œé¢

ä»`requestPayment`

> å‘ç”¨æˆ·è¯·æ±‚ä»˜æ¬¾ã€‚è¿™å¯èƒ½éœ€è¦å‘ç”¨æˆ·å‘ˆç°ä¸€äº›è¡¥å……çš„ UIï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒå°†å‘ˆç°åœ¨æ”¯ä»˜ä¸Šä¸‹æ–‡çš„`hostViewController`ä¸Šã€‚ä¾‹å¦‚ï¼Œå¦‚æœä»–ä»¬é€‰æ‹©äº† Apple Pay ä½œä¸ºä»–ä»¬çš„æ”¯ä»˜æ–¹å¼ï¼Œè°ƒç”¨è¯¥æ–¹æ³•å°†æ˜¾ç¤ºæ”¯ä»˜å•ã€‚å¦‚æœç”¨æˆ·æœ‰ä¸€å¼ å¡ç‰‡ï¼Œè¿™å°†ä½¿ç”¨å®ƒè€Œä¸æ˜¾ç¤ºä»»ä½•é¢å¤–çš„ UIã€‚åœ¨è¿™ä¸ªè¢«è°ƒç”¨ä¹‹åï¼Œ`paymentContext:didCreatePaymentResult:completion:`å’Œ`paymentContext:didFinishWithStatus:error:`æ–¹æ³•å°†åœ¨ä¸Šä¸‹æ–‡çš„`delegate`ä¸Šè¢«è°ƒç”¨ã€‚

ä½¿ç”¨`STPPaymentOptionsViewController`æ¥æ˜¾ç¤ºå¡ç‰‡å’Œ Apple Pay é€‰é¡¹

`requestPayment`ä»£ç ä¸º

```
- (void)requestPayment {
    WEAK(self);
    [[[self.didAppearPromise voidFlatMap:^STPPromise * _Nonnull{
        STRONG(self);
        return self.loadingPromise;
    }] onSuccess:^(__unused STPPaymentOptionTuple *tuple) {
        STRONG(self);
        if (!self) {
            return;
        }

        if (self.state != STPPaymentContextStateNone) {
            return;
        }

        if (!self.selectedPaymentOption) {
            [self presentPaymentOptionsViewControllerWithNewState:STPPaymentContextStateRequestingPayment];
        }
        else if ([self requestPaymentShouldPresentShippingViewController]) {
            [self presentShippingViewControllerWithNewState:STPPaymentContextStateRequestingPayment];
        }
        else if ([self.selectedPaymentOption isKindOfClass:[STPCard class]] ||
                 [self.selectedPaymentOption isKindOfClass:[STPSource class]]) {
            self.state = STPPaymentContextStateRequestingPayment;
            STPPaymentResult *result = [[STPPaymentResult alloc] initWithSource:(id<STPSourceProtocol>)self.selectedPaymentOption];
            [self.delegate paymentContext:self didCreatePaymentResult:result completion:^(NSError * _Nullable error) {
                stpDispatchToMainThreadIfNecessary(^{
                    if (error) {
                        [self didFinishWithStatus:STPPaymentStatusError error:error];
                    } else {
                        [self didFinishWithStatus:STPPaymentStatusSuccess error:nil];
                    }
                });
            }];
        }
        else if ([self.selectedPaymentOption isKindOfClass:[STPApplePayPaymentOption class]]) {
      // .... 
```

## [](#payment-options)æ”¯ä»˜é€‰é¡¹

```
func paymentOptionsViewController(_ paymentOptionsViewController: STPPaymentOptionsViewController, didSelect paymentOption: STPPaymentOption) {
    // No op
} 
```

ç”¨æˆ·é€‰æ‹©æ”¯ä»˜é€‰é¡¹åï¼Œæ›´æ”¹å°†ä¿å­˜åœ¨ä»ªè¡¨æ¿`https://dashboard.stripe.com/test/customers`ä¸­ï¼Œä½†ä»…é€‚ç”¨äºå¡ã€‚é€‰æ‹© Apple Pay ä¸åæ˜  web dashboard ä¸­çš„æ›´æ”¹ã€‚

Apple pay é€‰é¡¹æ˜¯æœ¬åœ°æ‰‹åŠ¨æ·»åŠ çš„ï¼Œä»`STPCustomer+SourceTuple.m`ğŸ˜²

```
- (STPPaymentOptionTuple *)filteredSourceTupleForUIWithConfiguration:(STPPaymentConfiguration *)configuration {
    id<STPPaymentOption> _Nullable selectedMethod = nil;
    NSMutableArray<id<STPPaymentOption>> *methods = [NSMutableArray array];
    for (id<STPSourceProtocol> customerSource in self.sources) {
        if ([customerSource isKindOfClass:[STPCard class]]) {
            STPCard *card = (STPCard *)customerSource;
            [methods addObject:card];
            if ([card.stripeID isEqualToString:self.defaultSource.stripeID]) {
                selectedMethod = card;
            }
        }
        else if ([customerSource isKindOfClass:[STPSource class]]) {
            STPSource *source = (STPSource *)customerSource;
            if (source.type == STPSourceTypeCard
                && source.cardDetails != nil) {
                [methods addObject:source];
                if ([source.stripeID isEqualToString:self.defaultSource.stripeID]) {
                    selectedMethod = source;
                }
            }
        }
    }

    return [STPPaymentOptionTuple tupleWithPaymentOptions:methods
                                    selectedPaymentOption:selectedMethod
                                        addApplePayOption:configuration.applePayEnabled];
} 
```

STPApplePayPaymentOption`is not available in`payment context . payment options `ç«‹å³

## [](#change-selected-payment-option)æ›´æ”¹é€‰ä¸­çš„æ”¯ä»˜é€‰é¡¹

åœ¨`STPPaymentContext`

`setSelectedPaymentOption`æ˜¯åªè¯»çš„å¹¶è§¦å‘`paymentContextDidChange`ï¼Œä½†å®ƒæ£€æŸ¥`the new selected payment option`æ˜¯å¦ç­‰äºç°æœ‰çš„æ‰€é€‰æ”¯ä»˜é€‰é¡¹

``objc`

 `*   (è¯·å‚é˜…)setselectedpayment option:(id)selected payment option { if(é€‰å®šä»˜æ¬¾é€‰é¡¹)&ï¼[self . payment options contained subject:selected payment option]{ self . payment options =[self . payment options arraybyaddingobject:selected payment option]ï¼š}å¦‚æœ(ï¼[_ selected payment option isequal:selected payment option]){ _ selected payment option = selected payment optionï¼›ã€è‡ªæˆ‘å§”æ‰˜èƒŒæ™¯ä»˜æ¬¾å˜æ›´:è‡ªæˆ‘ã€‘ï¼›})ï¼›} `

 `è¿˜æœ‰åœ¨`init`è°ƒç”¨çš„`retryLoading`

``objc`

 `*   (void)retryLoading {
    //åœ¨é‡æ–°æå–
    ä¹‹å‰æ¸…é™¤ä»»ä½•ç¼“å­˜çš„å®¢æˆ·å¯¹è±¡ if([self . API adapter is kindof class:[STPCustomerContext class]]){
    STPCustomerContext * customer context =(STPCustomerContext *)self . API adapterï¼›
    ã€customer context clearCachedCustomerã€‘ï¼›
    }
    è½¯å¼±(è‡ªæˆ‘)ï¼›
    self . loading promise =[[[STP promise new]onsuccess:^(stppaymentoptiontuple *å…ƒç»„){
    strong(self)ï¼›
    self . payment options = tuple . payment optionsï¼›
    self . selectedpaymentoption = tuple . selectedpaymentoptionï¼›
    }] onFailure:^(NSError * *éç©ºè¯¯å·®){
    å¼º(è‡ª)ï¼›
    if(self . hostviewcontroller){
    ã€self . didappearpromise onsuccess:^(*_ æœªä½¿ç”¨çš„ id å€¼){
    if(self . paymentoptions view controller){
    ã€self appreciallydismissspaymentoptions view controller:self . paymentoptions view controller completion:^{
    ã€self . delegate payment context:self didfailtoloadwitherror:errorã€‘ï¼›
    }]ï¼›
    } else {
    [self . delegate payment context:self didFailToLoadWithError:error]ï¼›
    }
    }]ï¼›
    }
    }]ï¼›
    ã€self . API adapter retrievecustomer:^(stpcustomer * _ å¯ç©ºå®¢æˆ·ï¼Œnserror * _ å¯ç©ºé”™è¯¯){
    stpdispatchtomainthreadifnecessary(^{
    å¼º(self)ï¼›
    å¦‚æœ(ï¼è‡ªæˆ‘){
    è¿”å›ï¼›
    }
    if(error){
    ã€self . loading promise fail:errorã€‘ï¼›
    è¿”å›ï¼›
    }
    å¦‚æœ(ï¼self . shipping address&T41ã€‘customer . shipping address){
    self . shipping address = customer . shipping addressï¼›
    self . shipping address needs verification = YESï¼›
    }

    ```
     STPPaymentOptionTuple *paymentTuple = [customer filteredSourceTupleForUIWithConfiguration:self.configuration];

        [self.loadingPromise succeed:paymentTuple];
    }); 
    ```

    }];
    }
    `

 `ä¾æ¬¡è°ƒç”¨`STPCustomerEphemeralKeyProvider`ã€‚ç”±äº stripe ä¸åœ¨ dashboard ä¸­ä¿å­˜ Apple Pay é€‰é¡¹ï¼Œæ­¤æ–¹æ³•ä¼šè¿”å›å¡æ”¯ä»˜é€‰é¡¹åˆ—è¡¨ï¼Œä»¥åŠé»˜è®¤å¡ä½œä¸ºæ‰€é€‰æ”¯ä»˜é€‰é¡¹ğŸ˜²

è™½ç„¶æ–°çš„`STPCard`æœ‰ä¸åŒçš„åœ°å€ï¼Œä½†å®ƒæ˜¯å…·æœ‰ç›¸åŒä¿¡æ¯çš„å®Œå…¨ç›¸åŒçš„å¡ï¼Œ`STPCard`çš„`isEqual`æ–¹æ³•æ˜¯

``objc`

 `*   (BOOL)isEqualToCard:(å¯ç©º STP card *)other {
    if(self = = other){
    è¿”å› YES
    }

    å¦‚æœ(ï¼å…¶ä»–||ï¼[other isKindOfClass:self . class]){
    return NOï¼›
    }

    return[self . stripeid isEqualToString:other . stripeid]ï¼›
    }
    `

 `æˆ‘æå‡ºäº†ä¸€ä¸ªé—®é¢˜[å¦‚ä½•æ›´æ”¹é€‰æ‹©çš„ä»˜æ¬¾é€‰é¡¹ï¼Ÿ](https://github.com/stripe/stripe-ios/issues/1175)å¸Œæœ›è¿™ä¸ªé—®é¢˜å¾ˆå¿«å¾—åˆ°è§£å†³ğŸ˜¢

åŸå¸–[https://github.com/onmyway133/blog/issues/219](https://github.com/onmyway133/blog/issues/219)``````