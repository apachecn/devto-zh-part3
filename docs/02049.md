# åœ¨ Rust ä¸­åˆ›å»ºâ€œåˆ†é¡µâ€Vec

> åŸæ–‡:[https://dev.to/kdrakon/creating-a-paged-vec-in-rust-193l](https://dev.to/kdrakon/creating-a-paged-vec-in-rust-193l)

åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘å°†å‘ä½ å±•ç¤ºä¸€äº›æˆ‘åœ¨ Rust ä¸­ä¸ºç»™ä¸€ä¸ª`Vec`é›†åˆåˆ†é¡µè€Œå†™çš„ä»£ç ã€‚æˆ‘å†™çš„ CLI å·¥å…·éœ€è¦å®ƒæ¥æ˜¾ç¤ºä»è¿œç¨‹æœåŠ¡å™¨è·å–çš„æ‰€æœ‰å‘é‡æ¡ç›®ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæˆ‘å¸Œæœ›æ”¶åˆ°å¾ˆå¤šç»“æœï¼Œæ‰€ä»¥ä¸ºäº†åœ¨ç»ˆç«¯ä¸­æœ‰æ•ˆåœ°æ˜¾ç¤ºå®ƒä»¬ï¼Œæˆ‘æ— æ³•åˆç†åœ°å‘ˆç°æ‰€æœ‰ç»“æœã€‚æˆ‘å†³å®šæˆ‘å°†é¡µé¢çš„ç»“æœã€‚ç„¶è€Œï¼Œæˆ‘æ„è¯†åˆ°æˆ‘è¿˜æƒ³è¦ä»¥ä¸‹è¿™äº›:

*   æˆ‘æƒ³è·Ÿè¸ªç”¨æˆ·å¯¹æºå‘é‡ä¸­å…ƒç´ çš„é€‰æ‹©ï¼Œ**å’Œ**ï¼Œ
*   æˆ‘æƒ³åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºç”¨æˆ·çš„é€‰æ‹©ï¼Œä»¥ä¾¿æ˜¾ç¤º(ä¾‹å¦‚ï¼Œçªå‡ºæ˜¾ç¤ºä»–ä»¬çš„å…‰æ ‡é€‰æ‹©)ã€‚

ç›´è§‰ä¸Šï¼Œè¿™äº›æŒ‡æ•°ä¼šæœ‰æ‰€ä¸åŒã€‚æˆ‘æ„è¯†åˆ°æˆ‘éœ€è¦ä¸€ä¸ªæ•°æ®ç»“æ„æ¥å›ç­”ä»¥ä¸‹é—®é¢˜:

> "ä»€ä¹ˆå…ƒç´ å’Œå…ƒç´ `n`åœ¨åŒä¸€ä¸ªé¡µé¢ä¸Šï¼Œå®ƒçš„ç´¢å¼•æ˜¯ä»€ä¹ˆï¼Ÿ"ã€‚

æˆ‘çš„æ–¹æ³•æ˜¯ä¿ç•™å®Œæ•´çš„çŸ¢é‡ï¼Œä½†ä¸€æ¬¡åªæ˜¾ç¤ºä¸€é¡µã€‚è¿™ä¸ªâ€œé¡µé¢â€å°±æ˜¯å½“å‰ç´¢å¼•å’Œç”¨æˆ·å…‰æ ‡æ‰€åœ¨çš„ä½ç½®ã€‚

`PagedVec`è·å–ä¸€ä¸ª`Vec<A>`å¹¶åœ¨å†…éƒ¨åˆ›å»ºä¸€ä¸ª`Vec<Vec<&A>>`ï¼Œå®ƒä»æºå‘é‡ä¸­å¼•ç”¨æ‰€æœ‰çš„`A`ã€‚ä½¿ç”¨`impl`æ–¹æ³•`page_for`ï¼Œæ‚¨å¯ä»¥éšæ„è·å¾—:

*   a)æºå‘é‡ç´¢å¼•çš„â€œé¡µé¢â€,ä»¥åŠ
*   b)è¯¥â€œé¡µé¢â€çš„æ¨¡æ•°è½¬æ¢ç´¢å¼•ã€‚

ä¾‹å¦‚:

```
let some_vec = vec![1, 2, 3, 4, 5, 6, 7, 8];
let paged = PagedVec::from(some_vec, 3);

let page_1 = paged.page_for(0); // Some(0, vec![1, 2, 3])
let page_1 = paged.page_for(1); // Some(1, vec![1, 2, 3])
let page_1 = paged.page_for(2); // Some(2, vec![1, 2, 3])

let page_2 = paged.page_for(3); // Some(0, vec![4, 5, 6])

let page_3 = paged.page_for(7); // Some(1, vec![7, 8]) 
```

æˆ‘æœ€åˆçš„å®ç°ä»£ç å¦‚ä¸‹ğŸ‘‡ã€‚çœŸæ­£çš„é­”åŠ›æ¥è‡ªæ ‡å‡†çš„ libs `chunks`æ–¹æ³•ï¼›å®ƒä¸»è¦è´Ÿè´£é¡µé¢åˆ†åŒºã€‚

```
pub struct PagedVec<'a, A: 'a> {
    page_length: usize,
    pages: Vec<Vec<&'a A>>,
}

impl<'a, A> PagedVec<'a, A> {
    pub fn from(vec: &'a Vec<A>, page_length: usize) -> PagedVec<'a, A> {
        PagedVec {
            page_length,
            pages: vec.chunks(page_length).map(|slice| {
                slice.iter().collect::<Vec<&'a A>>()
            }).collect::<Vec<Vec<&'a A>>>(),
        }
    }

    pub fn page_for(&'a self, index: usize) -> Option<(usize, &'a Vec<&'a A>)> {
        self.pages.get((index as f32 / self.page_length as f32).floor() as usize)
        .map(|page| {
            (
                index % self.page_length,
                page
            )
        })
    }
} 
```

è¿™ä¸ªå®ç°ä¸­æˆ‘æœ€å–œæ¬¢çš„éƒ¨åˆ†:ä½¿ç”¨ Rust çš„[å¼•ç”¨å’Œå€Ÿç”¨](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)åŠŸèƒ½ï¼Œæˆ‘å‡ ä¹ä¸ç”¨é¢å¤–åˆ†é…å †å°±èƒ½åšåˆ°è¿™ä¸€ç‚¹ã€‚å¾ˆç®€å•ï¼Œæ‰€æœ‰çš„â€œé¡µé¢â€åŸºæœ¬ä¸Šéƒ½æ˜¯æŒ‡å‘å­˜åœ¨äºåŸå§‹å‘é‡ä¸­çš„æ•°æ®çš„æŒ‡é’ˆã€‚å¦‚æœå‘é‡çš„å…ƒç´ æ˜¯å·¨å¤§çš„ T4ï¼Œé‚£ä¹ˆâ€œé¡µé¢â€å°±ä¸ä¼šå¤åˆ¶å†…å­˜ä¸­çš„æ•°æ®é‡ã€‚æœ‰ç‚¹åƒå…³ç³»æ•°æ®åº“ä¸­çš„è§†å›¾ã€‚

åœ¨ä½¿ç”¨è¿™ä¸ªä¹‹åä¸ä¹…ï¼Œæˆ‘æ„è¯†åˆ°æˆ‘å¯ä»¥é€šè¿‡ä¸ä¿ç•™æˆ‘å®é™…ä¸Šæ²¡æœ‰æ˜¾ç¤ºçš„é¡µé¢æ¥å‡å°‘æˆ‘çš„å†…å­˜ä½¿ç”¨ã€‚å†³å®šä½¿ç”¨ä¸‹é¢çš„å®ç°æ˜¯åŸºäºæˆ‘çš„ CLI å·¥å…·ç‰¹æœ‰çš„å› ç´ çš„è®¾è®¡é€‰æ‹©ã€‚

```
pub struct PagedVec<'a, A: 'a> {
    page_length: usize,
    vec: &'a Vec<A>,
}

impl<'a, A> PagedVec<'a, A> {
    pub fn from(vec: &'a Vec<A>, page_length: usize) -> PagedVec<'a, A> {
        PagedVec { page_length, vec }
    }

    pub fn page(&'a self, index: usize) -> Option<(usize, Vec<&'a A>)> {
        let mut paged = self.vec.chunks(self.page_length);
        let opt_page = paged.nth((index as f32 / self.page_length as f32)
          .floor() as usize);

        opt_page.map(|page| (index % self.page_length, page.iter().collect::<Vec<&'a A>>()))
    }
} 
```

é™¤äº†`chunks`ï¼Œè¿™é‡Œçš„é­”æœ¯æ˜¯`nth`çš„ä½¿ç”¨ï¼›ä¸ä»æºå‘é‡åˆ›å»ºæ‰€æœ‰é¡µé¢ä¸åŒï¼Œ`nth`â€”â€”ç»“åˆ Rust [è¿­ä»£å™¨](https://doc.rust-lang.org/book/ch13-02-iterators.html)çš„ [*æƒ°æ€§æ±‚å€¼*](https://en.wikipedia.org/wiki/Lazy_evaluation)â€”â€”å…è®¸æˆ‘åªåˆ›å»ºåˆ°æ‰€é€‰ç´¢å¼•çš„é¡µé¢ã€‚ä¸è¦å†æµªè´¹æ—¶é—´æˆ–è®°å¿†å»ºç«‹æˆ‘ä¸éœ€è¦çš„é¡µé¢ï¼ğŸ˜

æœ‰äº›æƒ…å†µä¸‹ï¼Œä½¿ç”¨åŸå§‹å®ç°å°†æ‰€æœ‰é¡µé¢ä¿å­˜åœ¨å†…å­˜ä¸­ä¼šæ›´å¥½ã€‚å“ªä¸ªæ›´å¥½ï¼Ÿè¿™å–å†³äºæ‚¨çš„ç”¨ä¾‹ğŸ¤·â€â™€ï¸.

**2019 å¹´ 3 æœˆ 6 æ—¥æ›´æ–°**
åœ¨åˆ†äº«äº†æˆ‘çš„å®ç°åï¼Œç¤¾åŒºä¸­çš„ä¸€äº› Rust devs èƒ½å¤ŸæŒ‡å‡ºæˆ‘ä»£ç ä¸­çš„ä¸€äº›æ”¹è¿›ã€‚

Reddit ç”¨æˆ· [2brainz](https://www.reddit.com/user/2brainz/) èƒ½å¤Ÿåˆ†äº«ä¸€ä¸ªé€šç”¨çš„å¹¶ä¸”å®Œå…¨å…è´¹åˆ†é…çš„`PagedVec`å®ç°ï¼Œå¦‚ä¸‹:

```
use std::{cmp::min, marker::PhantomData};

pub struct Paged<'a, T, V> {
    vec: &'a V,
    page_length: usize,
    phantom: PhantomData<&'a T>,
}

impl<'a, T, V> Paged<'a, T, V>
where
    V: AsRef<[T]>,
{
    pub fn new(vec: &'a V, page_length: usize) -> Paged<'a, T, V> {
        Paged {
            vec,
            page_length,
            phantom: PhantomData,
        }
    }

    pub fn page(&self, index: usize) -> Option<(usize, &'a [T])> {
        let slice = self.vec.as_ref();
        let len = slice.len();

        if index < len {
            let page_index = index % self.page_length;
            let start = index - page_index;
            let end = min(len, start + self.page_length);

            slice.get(start..end).map(|s| (page_index, s))
        } else {
            None
        }
    }
} 
```

è¿™é‡Œçš„èŠ‚çœæ˜¯åŸºäºç®€å•åœ°ä½¿ç”¨æ”¯æŒæ‰€æä¾›çš„`Vec`çš„åˆ‡ç‰‡ã€‚

æ­¤å¤–ï¼Œæˆ‘å¾ˆæƒ­æ„§åœ°è¯´ï¼Œæˆ‘ç¡®å®å¿˜è®°äº†åœ¨ä»»ä½•ç¼–ç¨‹è¯­è¨€ä¸­ä½¿ç”¨æµ®åŠ¨ç±»å‹çš„ä¸€äº›è°¬è¯¯ã€‚è®¸å¤š Rust devs æé†’æˆ‘ï¼Œa)å¯¹äºæ•°å­—é™¤æ³•ï¼Œfloor é€šå¸¸æ˜¯éšå¼çš„ï¼Œb)float ä»æ¥éƒ½ä¸ç²¾ç¡®ã€‚ä¸ºæŒ‡å‡º[shadow 0133
T2 å’Œ](https://www.reddit.com/user/Shadow0133/) [2brainz](https://www.reddit.com/user/2brainz/) è€Œæ¬¢å‘¼ã€‚