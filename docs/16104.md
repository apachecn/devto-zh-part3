# åœ¨ Swift ä¸­ä½¿ç”¨å›¾åƒé€‰æ‹©é¢œè‰²

> åŸæ–‡:[https://dev . to/neriusv/selecting-colors-using-an-image-in-swift-27l 9](https://dev.to/neriusv/selecting-colors-using-an-image-in-swift-27l9)

å‰å‡ å¤©åœ¨æ¨ç‰¹ä¸Šçœ‹åˆ°ä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ã€‚

> iTunes åº”ç”¨ç¨‹åºå¦‚ä½•æ ¹æ®æµ·æŠ¥å›¾åƒçš„é¢œè‰²é€‰æ‹©è§†å›¾çš„èƒŒæ™¯é¢œè‰²ï¼Ÿ

ç­”æ¡ˆä¼¼ä¹å¾ˆç®€å•:

1.  é€‰æ‹©å›¾åƒçš„ä¸»è‰²ã€‚
2.  è®¾ç½®ä¸ºèƒŒæ™¯è‰²ã€‚
3.  é€‰æ‹©ä¸€ç§åœ¨é‚£ç§èƒŒæ™¯ä¸‹çœ‹èµ·æ¥ä¸é”™çš„é¢œè‰²ã€‚
4.  å°†å…¶ç”¨ä½œæ–‡æœ¬é¢œè‰²ã€‚

ç°å®ç”Ÿæ´»é€šå¸¸ä¸æ˜¯é‚£ä¹ˆç®€å•ï¼Œè€Œæ˜¯æœ‰è¶£å¾—å¤šã€‚

ä¸‹é¢æ˜¯æˆ‘å¯¹å®ƒçš„çœ‹æ³•:
[![Demo gif](../Images/70792da2f59bfee653a5688e7835663f.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--d1QHVS3---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/6ekaicpv5475uhl67grr.gif)

å¥½ï¼Œé‚£æˆ‘ä»¬å¼€å§‹å§ï¼æˆ‘å°†ä½¿ç”¨ Swiftã€UIKit å’Œ CoreGraphics ç±»ï¼Œå¦‚ *UIImage* ã€ *UIColor* ã€ *CGImage* ï¼Œä½†åŒæ ·çš„åŸåˆ™é€‚ç”¨äºä»»ä½•å…¶ä»–è¯­è¨€æˆ–æ¡†æ¶ã€‚

## [](#picking-the-dominant-color-of-an-image)æ‹¾å–å›¾åƒçš„ä¸»è‰²

æŒ‘é€‰ä¸»è‰²æœ€ç®€å•çš„æ–¹æ³•æ˜¯å–å›¾åƒçš„å¹³å‡é¢œè‰²ï¼Œå³æ‰€æœ‰åƒç´ çš„å€¼ç›¸åŠ ï¼Œç„¶åé™¤ä»¥åƒç´ çš„æ•°é‡ã€‚æˆ‘å¾ˆæƒŠè®¶è¿™ç§æ–¹æ³•å¦‚æ­¤æœ‰æ•ˆğŸ¤¯ã€‚è¯´çœŸçš„ï¼Œä½ å¯ä»¥å¿½ç•¥è¿™ç¯‡æ–‡ç« çš„å¤§éƒ¨åˆ†å†…å®¹ï¼Œåªä½¿ç”¨å¹³å‡é¢œè‰²ã€‚

å½“ç„¶ï¼Œåœ¨æŸäº›è¾¹ç¼˜æƒ…å†µä¸‹ï¼Œå¹³å‡å€¼å®é™…ä¸Šä¸èµ·ä½œç”¨:æƒ³è±¡ä¸€å¼ ä¸€åŠé»‘ä¸€åŠç™½çš„å›¾ç‰‡ã€‚å³ä½¿å›¾åƒä¸­æ²¡æœ‰ç°è‰²ï¼Œå¹³å‡å€¼ä¹Ÿæ˜¯ç°è‰²çš„ã€‚å¦ä¸€ä¸ªé€‰æ‹©å¯èƒ½æ˜¯*ä»¥æŸç§æ–¹å¼*è®¢è´­é¢œè‰²å¹¶æŒ‘é€‰[ä¸­é—´å€¼](https://en.wikipedia.org/wiki/Median)ã€‚ä½ å¯ä»¥æŒ‰è‰²è°ƒæˆ–é¥±å’Œåº¦æ¥æ’åºã€‚

ä½†æ˜¯è®©æˆ‘ä»¬æŠŠæ‰€æœ‰çš„äº‹æƒ…éƒ½å¤æ‚åŒ–ï¼Œä½¿ç”¨ä¸€ç§å«åš [k å‡å€¼èšç±»](https://en.wikipedia.org/wiki/K-means_clustering)çš„æŠ€æœ¯ã€‚

## K-å‡å€¼èšç±»

å¦‚æœä½ ç‚¹å‡»ç»´åŸºç™¾ç§‘çš„é“¾æ¥ï¼Œä½ å¯èƒ½ä¼šè¢«â€œä¿¡å·å¤„ç†â€å’Œâ€œç©ºé—´èŒƒå›´â€è¿™æ ·çš„è¯å¼„å¾—æ™•å¤´è½¬å‘ï¼Œä½†è¿™æ¯”å¬èµ·æ¥è¦ç®€å•ã€‚ç›¸ä¿¡æˆ‘ã€‚

å®ƒæ‰€åšçš„æ˜¯å°†æ•°æ®åˆ†æˆ *k* ä¸ªç»„(é›†ç¾¤)ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œå®ƒä¼šå°†å›¾åƒçš„æ‰€æœ‰é¢œè‰²åˆ†æˆ *k* ä¸ªç»„ï¼Œç„¶åä½ é€‰æ‹©å…¶ä¸­ä¸€ä¸ªç»„(é€šå¸¸æ˜¯æœ€å¤§çš„ä¸€ä¸ª)ï¼Œè®¡ç®—å®ƒçš„ä¸­å¿ƒ(åˆå*æ„æ€æ˜¯*)ï¼Œä½ å°±æœ‰äº†è¯¥å›¾åƒçš„ä¸»è‰²ã€‚

ç®—æ³•:

1.  ä»ä½ çš„å›¾åƒä¸­éšæœºé€‰æ‹© k ä¸ªé¢œè‰²ã€‚è¿™å°†æ˜¯ä½ çš„é›†ç¾¤çš„ä¸­å¿ƒã€‚
2.  è®¡ç®—ä»æ¯ä¸ªåƒç´ çš„é¢œè‰²åˆ°æ¯ä¸ªèšç±»ä¸­å¿ƒçš„è·ç¦»ã€‚
3.  å°†åƒç´ çš„é¢œè‰²åˆ†é…ç»™æœ€è¿‘çš„ç°‡ã€‚
4.  é€šè¿‡å–åˆ†é…ç»™è¯¥åˆ†ç±»çš„æ‰€æœ‰é¢œè‰²çš„å¹³å‡å€¼æ¥è®¡ç®—æ¯ä¸ªåˆ†ç±»çš„æ–°ä¸­å¿ƒã€‚
5.  è½¬åˆ° 2ã€‚é‡å¤æ­¤æ“ä½œï¼Œç›´åˆ°æ‰€æœ‰ç°‡çš„ä¸­å¿ƒä¸å†æ”¹å˜ã€‚

ä½ å¯èƒ½æƒ³çŸ¥é“ç©¶ç«Ÿå¦‚ä½•è®¡ç®—ä¸¤ç§é¢œè‰²æˆ–ä¸€ç§é¢œè‰²åˆ°æ˜Ÿå›¢ä¸­å¿ƒçš„è·ç¦»ï¼Ÿå¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å°†é¢œè‰²è§†ä¸º 3D ç©ºé—´ä¸­çš„ç‚¹ï¼é€šå¸¸ä¸€ç§é¢œè‰²ç”±ä¸‰ç§(æˆ–è€…å››ç§ï¼Œå¦‚æœä½ è€ƒè™‘é€æ˜åº¦çš„è¯)æˆåˆ†å®šä¹‰:çº¢è‰²ã€ç»¿è‰²ã€è“è‰²ï¼›æˆ–è€…è‰²è°ƒã€é¥±å’Œåº¦å’Œäº®åº¦ã€‚ä¸‰ç»´ç©ºé—´ä¸­çš„ç‚¹ä¹Ÿæ˜¯ç”±ä¸‰ä¸ªéƒ¨åˆ†å®šä¹‰çš„:Xï¼ŒY å’Œ Zã€‚æ‰€ä»¥çº¢è‰²å˜æˆ Xï¼Œç»¿è‰²å˜æˆ Yï¼Œè“è‰²å˜æˆ Zï¼Œçªç„¶ä½ å°±æœ‰äº†ä¸€ä¸ªä¸‰ç»´ç©ºé—´ä¸­çš„ç‚¹ï¼é‚£ä¹ˆè®¡ç®—ä¸¤ç§é¢œè‰²ä¹‹é—´çš„è·ç¦»å°±å’Œ[è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»](https://en.wikipedia.org/wiki/Euclidean_distance)ä¸€æ ·ç®€å•ã€‚

å¥½äº†ï¼Œæ˜¯æ—¶å€™å†™äº›ä»£ç äº†ï¼

## [](#resizing-the-image)è°ƒæ•´å›¾åƒå¤§å°

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å°†å›¾åƒçš„å¤§å°è°ƒæ•´åˆ°ä¸€ä¸ªå¯ç®¡ç†çš„å¤§å°(æ¯”å¦‚ 100x100)ï¼Œå¦åˆ™èšç±»å°†æ°¸è¿œè¿›è¡Œä¸‹å»ã€‚
è®©æˆ‘ä»¬ä¸º *UIImage* åšä¸€ä¸ªæ‰©å±•æ¥è°ƒæ•´å®ƒçš„å¤§å°:

```
extension UIImage {
    func resized(to size : CGSize) -> UIImage {
        let format = UIGraphicsImageRendererFormat()
        format.scale = 1
        //disable HDR:
        format.preferredRange = .standard
        let renderer = UIGraphicsImageRenderer(size: size, format: format)
        let result = renderer.image { (context) in
            self.draw(in: CGRect(origin: CGPoint.zero, size: size))
        }
        return result
    }
} 
```

## [](#getting-the-color-data)è·å–é¢œè‰²æ•°æ®

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦è·å–å›¾åƒä¸­æ‰€æœ‰åƒç´ çš„æ‰€æœ‰é¢œè‰²æ•°æ®ã€‚
æˆ‘çš„è§£å†³æ–¹æ¡ˆæ˜¯ä» *UIImage* è·å– *CGImage* ï¼Œå¹¶è·å–å›¾åƒæ•°æ®ï¼Œè¿™æ˜¯ä¸€ä¸ªå­—èŠ‚æ•°ç»„ã€‚å°†å­—èŠ‚å¤åˆ¶åˆ°ä¸€ä¸ªæ— ç¬¦å· 32 ä½æ•´æ•°æ•°ç»„ä¸­ã€‚è¿™ç»™å‡ºäº†ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ ä»£è¡¨ä¸€ä¸ªåƒç´ çš„é¢œè‰²ã€‚
éå†è¿™ä¸ªæ•°ç»„ï¼Œä½¿ç”¨ä¸€äº›é€ä½é­”æ³•æå–çº¢è‰²ã€ç»¿è‰²å’Œè“è‰²æˆåˆ†ï¼Œæœ€ååˆ›å»ºä¸€ä¸ª *UIColor* çš„å®ä¾‹ã€‚

è¿™ä¼¼ä¹æ¯”å®ƒåº”è¯¥çš„è¦å¤æ‚å¾—å¤šã€‚å¦‚æœä½ çŸ¥é“ä¸€ä¸ªæ›´å¥½çš„å°† UIImage è½¬æ¢æˆ T2 ui color æ•°ç»„çš„æ–¹æ³•ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼

```
extension UIImage {
    func getPixels() -> [UIColor] {
        guard let cgImage = self.cgImage else {
            return []
        }
        assert(cgImage.bitsPerPixel == 32, "only support 32 bit images")
        assert(cgImage.bitsPerComponent == 8,  "only support 8 bit per channel")
        guard let imageData = cgImage.dataProvider?.data as Data? else {
            return []
        }
        let size = cgImage.width * cgImage.height
        let buffer = UnsafeMutableBufferPointer<UInt32>.allocate(capacity: size)
        _ = imageData.copyBytes(to: buffer)
        var result = [UIColor]()
        result.reserveCapacity(size)
        for pixel in buffer {
            var r : UInt32 = 0
            var g : UInt32 = 0
            var b : UInt32 = 0
            if cgImage.byteOrderInfo == .orderDefault || cgImage.byteOrderInfo == .order32Big {
                r = pixel & 255
                g = (pixel >> 8) & 255
                b = (pixel >> 16) & 255
            } else if cgImage.byteOrderInfo == .order32Little {
                r = (pixel >> 16) & 255
                g = (pixel >> 8) & 255
                b = pixel & 255
            }
            let color = UIColor(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: 1)
            result.append(color)
        }
        return result
    }
} 
```

æˆ‘çŸ¥é“ï¼ŒğŸ˜±ï¼ä½†æ˜¯è¯´çœŸçš„ï¼Œè¿™æ˜¯æœ€å›°éš¾çš„éƒ¨åˆ†ã€‚

## [](#defining-the-data-structures)å®šä¹‰æ•°æ®ç»“æ„

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹ä¾¿çš„æ–¹æ³•æ¥è®¡ç®—é¢œè‰²/ç‚¹ã€‚ä½ å¯ä»¥ä¸º *UIColor* å®ç°å‡ ä¸ªæ‰©å±•å‡½æ•°ï¼Œä½†æ˜¯æˆ‘å†³å®šåˆ›å»ºä¸€ä¸ªæ–°çš„*ç‚¹*ç»“æ„:

```
struct Point : Equatable {
    let x : CGFloat
    let y : CGFloat
    let z : CGFloat
    init(_ x: CGFloat, _ y : CGFloat, _ z : CGFloat) {
        self.x = x
        self.y = y
        self.z = z
    }
    init(from color : UIColor) {
        var r : CGFloat = 0
        var g : CGFloat = 0
        var b : CGFloat = 0
        var a : CGFloat = 0
        if color.getRed(&r, green: &g, blue: &b, alpha: &a) {
            x = r
            y = g
            z = b
        } else {
            x = 0
            y = 0
            z = 0
        }
    }
    func toUIColor() -> UIColor {
        return UIColor(red: x, green: y, blue: z, alpha: 1)
    }
    static func == (lhs: Point, rhs: Point) -> Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z
    }
} 
```

æˆ‘ä»¬ç°åœ¨æœ‰äº†ä¸€ä¸ªç®€å•çš„æ–¹æ³•æ¥è½¬æ¢ UIColor å’Œæˆ‘ä»¬çš„ T2 ç‚¹ç»“æ„ã€‚æ¥ä¸‹æ¥è®©æˆ‘ä»¬å®šä¹‰å‡ ä¸ªè¾…åŠ©æ“ä½œç¬¦:

```
static let zero = Point(0, 0, 0)
static func +(lhs : Point, rhs : Point) -> Point {
    return Point(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z)
}
static func /(lhs : Point, rhs : CGFloat) -> Point {
    return Point(lhs.x / rhs, lhs.y / rhs, lhs.z / rhs)
} 
```

...å’Œè®¡ç®—ä¸¤ç‚¹é—´è·ç¦»çš„å‡½æ•°ã€‚

```
func distanceSquared(to p : Point) -> CGFloat {
    return (self.x - p.x) * (self.x - p.x)
        + (self.y - p.y) * (self.y - p.y)
        + (self.z - p.z) * (self.z - p.z)
} 
```

æ³¨æ„ï¼Œå®ƒè¿”å›çš„æ˜¯*çš„å¹³æ–¹*çš„è·ç¦»ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹ç»“æœæ±‚å¹³æ–¹æ ¹æ¥å¾—åˆ°çœŸå®çš„è·ç¦»ï¼Œä½†æ˜¯åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿™æ²¡æœ‰å®é™…çš„åŒºåˆ«ã€‚æŠŠå®ƒçœ‹åšæ˜¯ä¸€æ¬¡æ€§èƒ½ä¼˜åŒ–ã€‚

æ¥ä¸‹æ¥è®©æˆ‘ä»¬åˆ›å»º*é›†ç¾¤*ç±»ã€‚å®ƒåªéœ€è¦ä¸€ä¸ªä¸­å¿ƒç‚¹å’Œä¸€ä¸ªæ•°ç»„æ¥ä¿å­˜æŒ‡å®šçš„ç‚¹:

```
class Cluster {
    var points = [Point]()
    var center : Point
    init(center : Point) {
        self.center = center
    }
} 
```

æˆ‘ä»¬è¿˜éœ€è¦ä¸€ç§æ–¹æ³•æ¥è®¡ç®—æ•°ç»„ä¸­ç‚¹çš„ä¸­å¿ƒ:

```
func calculateCurrentCenter() -> Point {
    if points.isEmpty {
        return Point.zero
    }
    return points.reduce(Point.zero, +) / points.count
} 
```

å®ƒé€šè¿‡å¯¹æ¯ä¸ªåˆ†é‡æ±‚å’Œå¹¶é™¤ä»¥ç‚¹æ•°æ¥è®¡ç®—æ‰€æœ‰ç‚¹çš„æ•°å­¦å¹³å‡å€¼ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™ä¸ªæ•°å­¦å¹³å‡å€¼ä½œä¸ºæ–°çš„ä¸­å¿ƒï¼Œä½†æ˜¯è¿˜è®°å¾—å›¾åƒåªåŒ…å«é»‘ç™½åƒç´ è€Œå¹³å‡å€¼æ˜¯ç°è‰²çš„è¾¹ç¼˜æƒ…å†µå—ï¼Ÿä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¸ä½¿ç”¨å¹³å‡å€¼ï¼Œè€Œæ˜¯æ‰¾åˆ°ä¸€ä¸ªæœ€æ¥è¿‘å¹³å‡å€¼çš„ç°æœ‰ç‚¹ï¼Œå¹¶å°†å…¶ä½œä¸ºæ–°çš„ä¸­å¿ƒ:

```
func updateCenter() {
    if points.isEmpty {
        return
    }
    let currentCenter = calculateCurrentCenter()
    center = points.min(by: {$0.distanceSquared(to: currentCenter) < $1.distanceSquared(to: currentCenter)})!
} 
```

è¿™é‡Œæˆ‘ä½¿ç”¨ Swift çš„æ ‡å‡†åº“çš„ [min(by:)](https://developer.apple.com/documentation/swift/array/2298201-min) å‡½æ•°æ¥å¯»æ‰¾åˆ°ä¸­å¿ƒè·ç¦»æœ€å°çš„ç‚¹ã€‚

æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªå‡½æ•°æ¥æ‰¾åˆ°æœ€æ¥è¿‘ä¸€ä¸ªç‚¹çš„ç°‡:

```
private func findClosest(for p : Point, from clusters: [Cluster]) -> Cluster {
    return clusters.min(by: {$0.center.distanceSquared(to: p) < $1.center.distanceSquared(to: p)})!
} 
```

## [](#clustering)èšç±»

æœ€åï¼Œæˆ‘ä»¬å‡†å¤‡å¥½å®ç°é›†ç¾¤äº†ï¼
è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œå®ƒå°†æ¥å—ä¸€ä¸ªç‚¹åˆ—è¡¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªç”± *k ä¸ª*ç°‡ç»„æˆçš„æ•°ç»„:

```
func cluster(points : [Point], into k : Int) -> [Cluster] {
} 
```

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä»åˆ—è¡¨ä¸­éšæœºé€‰å– k ä¸ªç‚¹ï¼Œç¡®ä¿æˆ‘ä»¬ä¸ä¼šæ„å¤–åœ°é€‰å–ä¸¤ä¸ªç›¸åŒçš„ç‚¹ï¼

```
var clusters = [Cluster]()
for _ in 0 ..< k {
    var p = points.randomElement()
    while p == nil || clusters.contains(where: {$0.center == p}) {
        p = points.randomElement()
    }
    clusters.append(Cluster(center: p!))
} 
```

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†æ¯ä¸ªç‚¹åˆ†é…åˆ°æœ€è¿‘çš„ç°‡:

```
for p in points {
    let closest = findClosest(for: p, from: clusters)
    closest.points.append(p)
} 
```

ç°åœ¨è®©æˆ‘ä»¬è®¡ç®—æ¯ä¸ªé›†ç¾¤çš„æ–°ä¸­å¿ƒç‚¹:

```
clusters.forEach {
    $0.updateCenter()
} 
```

å’Œ...å°±æ˜¯è¿™æ ·ï¼é‡å¤å‡ æ¬¡ï¼Œä½ ä¼šå°†æ¯ä¸ªç‚¹åˆ†é…åˆ°æœ€ä½³åŒ¹é…çš„èšç±»ã€‚é€šå¸¸éœ€è¦å¤§çº¦ 5 æ¬¡è¿­ä»£æ‰èƒ½ä½¿ä¸­å¿ƒæ”¶æ•›ï¼Œæ‰€ä»¥ä½ åªéœ€å¾ªç¯ 5 æˆ– 10 æ¬¡å°±èƒ½å¾—åˆ°ä¸€ä¸ªå¯æ¥å—çš„ç»“æœã€‚ä½†æ˜¯è®©æˆ‘ä»¬å®ç°ä¸€ä¸ªæµ‹è¯•ï¼Œé€šè¿‡æ£€æŸ¥ä¸€ä¸ªé›†ç¾¤çš„æ–°æ—§ä¸­å¿ƒä¹‹é—´çš„è·ç¦»æ¥æ£€æŸ¥ä¸­å¿ƒæ˜¯å¦ä¸å†ç§»åŠ¨ã€‚ä¸‹é¢æ˜¯æœ€ç»ˆä»£ç :

```
for i in 0 ..< 10 {
    clusters.forEach {
        $0.points.removeAll()
    }
    for p in points {
        let closest = findClosest(for: p, from: clusters)
        closest.points.append(p)
    }
    var converged = true
    clusters.forEach {
        let oldCenter = $0.center
        $0.updateCenter()
        if oldCenter.distanceSquared(to: $0.center) > 0.001 {
            converged = false
        }
    }
    if converged {
        print("Converged. Took \(i) iterations")
        break;
    }
} 
```

## [](#choosing-the-main-color)é€‰æ‹©ä¸»è‰²

æˆ‘ä»¬ç°åœ¨æœ‰äº†ä¸€ä¸ª k ä¸ªé›†ç¾¤çš„åˆ—è¡¨ã€‚
æˆ‘ä»¬å¦‚ä½•è·å¾—ä¸»è‰²ï¼Ÿå¥½å§ï¼Œå¦‚æœä½ æƒ³è¦ä¸»è‰²ï¼Œåªéœ€é€‰æ‹©åˆ†é…äº†æœ€å¤šç‚¹çš„ç°‡çš„ä¸­å¿ƒç‚¹ï¼Œå¹¶å°†å…¶è½¬æ¢å›ä¸€ä¸ª *UIColor* ã€‚
ä½ ä¹Ÿå¯ä»¥å°†æ‰€æœ‰çš„ä¸­å¿ƒè½¬æ¢æˆ *UIColor* å¹¶é€‰æ‹©é¥±å’Œåº¦æœ€é«˜(æˆ–æœ€å°)çš„ä¸€ä¸ªã€‚
ç°åœ¨ï¼Œè®©æˆ‘ä»¬é€‰æ‹©æœ€å¤§çš„é›†ç¾¤:

```
let clusters = kMeans.cluster(points: points, into: 3).sorted(by: {$0.points.count > $1.points.count})
let colors = clusters.map(({$0.center.toUIColor()}))
guard let mainColor = colors.first else {
    return
}
setBackgroundColor(mainColor) 
```

...å®Œæˆäº†ã€‚ğŸ¤—ä¸å®Œå…¨æ˜¯ã€‚æˆ‘ä»¬ä»ç„¶éœ€è¦é€‰æ‹©ä¸€ç§åœ¨æˆ‘ä»¬çš„ä¸»è‰²ä¸Šçœ‹èµ·æ¥ä¸é”™çš„é¢œè‰²æ¥ä½œä¸ºæ–‡æœ¬é¢œè‰²ã€‚

## [](#choosing-the-text-color)é€‰æ‹©æ–‡æœ¬é¢œè‰²

å…ˆä»æˆ‘ä»¬ä¸»è‰²çš„[è¡¥è‰²](https://en.wikipedia.org/wiki/Complementary_colors)å¼€å§‹ã€‚
æˆ‘ä»¬éœ€è¦å°†æˆ‘ä»¬çš„ä¸»è‰²ä» RGB è½¬æ¢åˆ° [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV) (è‰²è°ƒã€é¥±å’Œåº¦ã€äº®åº¦)è‰²å½©ç©ºé—´ã€‚å¹¸è¿çš„æ˜¯ï¼ŒUIColor å¯ä»¥ä¸ºæˆ‘ä»¬åšåˆ°è¿™ä¸€ç‚¹ã€‚ç„¶åæˆ‘ä»¬å°†æŠŠ*è‰²è°ƒ*ç»„ä»¶ç§»åŠ¨ 180 åº¦ã€‚è¿™å°†å¯¼è‡´äº’è¡¥è‰²ï¼Œç»™æˆ‘ä»¬æœ€é«˜çš„å¯¹æ¯”åº¦ã€‚æƒ³æƒ³è“è‰²èƒŒæ™¯ä¸Šçš„é»„è‰²æ–‡å­—ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦é™ä½å¯¹æ¯”åº¦ï¼Œè¿™æ ·å°±å¯ä»¥ä¸ç”¨çœ¯ç€çœ¼ç›é˜…è¯»æ–‡æœ¬äº†ã€‚è¿™éœ€è¦ä¸€äº›å°è¯•å’Œé”™è¯¯ï¼Œä½†æˆ‘å¾—åˆ°äº†å¾ˆå¥½çš„ç»“æœï¼Œåœ¨ä¸åŒçš„æ–¹å‘ç§»åŠ¨é¥±å’Œåº¦å’Œäº®åº¦ã€‚

æ˜¯æ—¶å€™å†™æ›´å¤šçš„ä»£ç äº†ï¼
æˆ‘ä»¬é¦–å…ˆéœ€è¦ä¸€ä¸ªç»“æ„æ¥å­˜å‚¨æˆ‘ä»¬çš„ HSL é¢œè‰²:

```
struct HSLColor {
    let hue, saturation, brightness, alpha : CGFloat
    init(hue : CGFloat, saturation : CGFloat, brightness : CGFloat, alpha : CGFloat = 1) {
        self.hue = hue
        self.saturation = saturation
        self.brightness = brightness
        self.alpha = alpha
    }
} 
```

æˆ‘ä»¬è¿˜éœ€è¦ä¸€ç§æ–¹æ³•æ¥å°†è‰²è°ƒã€é¥±å’Œåº¦å’Œäº®åº¦åˆ†é‡ç§»åŠ¨ä¸€å®šçš„é‡ã€‚ *UIColors* å°†å®ƒä»¬å­˜å‚¨åœ¨[0..1]åŒºé—´ï¼Œå› æ­¤ç»“æœéœ€è¦åœ¨æ­¤åŒºé—´å†…è¿›è¡Œä¸¤æ¬¡å›ç»•ã€‚
å‡è®¾å½“å‰å€¼ä¸º 0.8ï¼Œæˆ‘ä»¬æƒ³å°†å…¶ç§»åŠ¨ 0.6:
`0.8 + 0.6 = 1.4`
å°† 1.4 ç¯ç»•åœ¨[0..1]ç»™æˆ‘ä»¬ 0.4ã€‚
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Swift çš„[truncating reminder(divideing by:)](https://developer.apple.com/documentation/swift/double/2885641-truncatingremainder)å‡½æ•°æ¥å®ç°è¿™ä¸€ç‚¹ã€‚

èµ·åˆï¼Œæˆ‘è®¤ä¸ºè¿™å°±è¶³å¤Ÿäº†ï¼Œä½†æœ‰æ—¶è¿™ä¼šåœ¨é»‘æš—çš„èƒŒæ™¯ä¸Šäº§ç”Ÿè¿‡é¥±å’Œçš„æ˜äº®æ–‡æœ¬ï¼Œéš¾ä»¥é˜…è¯»ã€‚ç»è¿‡ä¸€äº›å®éªŒï¼Œæˆ‘å‘ç°é¥±å’Œåº¦å’Œäº®åº¦åº”è¯¥å‘ä¸åŒçš„æ–¹å‘è½¬ç§»:äº®åº¦ä¸Šå‡ï¼Œè€Œé¥±å’Œåº¦ä¸‹é™ã€‚å¦‚æœäº®åº¦å·²ç»å¾ˆé«˜ï¼Œå°±ä¼šç»•å›ã€‚ä½†æ˜¯è¿™ä¸åº”è¯¥å‘ç”Ÿåœ¨é¥±å’ŒçŠ¶æ€:å¦‚æœå®ƒå¾ˆä½ï¼Œå®ƒåº”è¯¥*è€Œä¸æ˜¯*ç¯ç»•å¹¶å˜é«˜ã€‚

è¿™æ˜¯æˆ‘æƒ³åˆ°çš„è§£å†³æ–¹æ¡ˆ:

```
private func shift(_ value : CGFloat, by amount : CGFloat) -> CGFloat {
    return abs((value + amount).truncatingRemainder(dividingBy: 1))
} 
```

å’Œä¸€äº›å¸®åŠ©å‡½æ•°æ¥ç§»åŠ¨æ¯ä¸ªç»„ä»¶:

```
func shiftHue(by amount : CGFloat) -> HSLColor {
    return HSLColor(hue: shift(hue, by: amount), 
                    saturation: saturation,
                    brightness: brightness, alpha: alpha)
}
func shiftBrightness(by amount : CGFloat) -> HSLColor {
    return HSLColor(hue: hue, saturation: saturation, 
                    brightness: shift(brightness, by: amount), alpha: alpha)
}
func shiftSaturation(by amount : CGFloat) -> HSLColor {
    return HSLColor(hue: hue, saturation: shift(saturation, by: amount), 
                    brightness: brightness, alpha: alpha)
} 
```

å”·ï¼Œå·®ä¸å¤šå°±æ˜¯è¿™æ ·ï¼æˆ‘ä»¬ç°åœ¨å·²ç»å‡†å¤‡å¥½ä»æˆ‘ä»¬çš„ä¸»è‰²ä¸­è®¡ç®—åŒ¹é…çš„æ–‡æœ¬é¢œè‰²:

```
func makeTextColor(from color : UIColor) -> UIColor {
        return color.hslColor.shiftHue(by: 0.5)
                            .shiftSaturation(by: -0.5)
                            .shiftBrightness(by: 0.5).uiColor
} 
```

ç°åœ¨æˆ‘ä»¬çœŸçš„ç»“æŸäº†ã€‚è¿™é‡Œæœ‰å‡ ä¸ªä¸åŒå›¾ç‰‡çš„ç»“æœ:
[![Sample Results](../Images/3551564ea8cdd98758427ab26fab4782.png)](https://res.cloudinary.com/practicaldev/image/fetch/s--nW0ORlm8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/0ryenw3u0u8wlcr91ity.jpg) 
æ³¨æ„ï¼Œç»“æœå–å†³äºåˆå§‹éšæœºé€‰æ‹©çš„èšç±»ä¸­å¿ƒï¼Œæ‰€ä»¥æ¯æ¬¡è¿è¡Œæ—¶ç»“æœä¼šç•¥æœ‰ä¸åŒã€‚

å®Œæ•´çš„æºä»£ç (ä½œä¸ºä¸€ä¸ª iOS åº”ç”¨ç¨‹åº)å¯ä»¥åœ¨ [GitHub](https://github.com/neriusv/dominant-color-swift-sample) ä¸Šè·å¾—ã€‚

å¸Œæœ›ä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼